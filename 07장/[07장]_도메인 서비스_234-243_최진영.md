# 도메인 서비스
## 7.1 여러 애그리거트가 필요한 기능

도메인 영역의 코드를 작성하다 보면, 한 애그리거트로 기능을 구현할 수 없을 때가 있습니다.

예시로는 '결제 금액 계산 로직'을 들어볼 수 있는데요. 실제 결제 금액을 계산할 때는 다음과 같은 내용이 필요합니다.
- `상품 애그리거트`: 구매하는 상품의 가격 or 상품에 따른 배송비
- `주문 애그리거트`: 상품별 구매 개수
- `할인 쿠폰 애그리거트`: 쿠폰별 할인 금액 등
- `회원 애그리거트`: 회원 등급에 따른 추가 할인 등

이 상황에서 `실제 결제 금액을 계산해야하는 주체`는 어떤 애그리거트일까요?

생각해 볼 수 있는 방법은 `주문 애그리거트가 필요한 데이터를 모두 가지도록`한 뒤 할인 금액 계산 책임을 주문 애그리거트에 할당하는 것입니다.

그래서 아래와 같은 코드가 될 수 있습니다.
```java
public class Order {
  private Orderer orderer;
  private List<OrderLine> orderLines;
  private List<Coupon> coupons;
  
  private Money calculatePayAmounts() {
    
    Money totalAmounts = calculateTotalAmounts();
    
    // 쿠폰 할인
    Money discount = calculateDiscount(coupons);
    
    // 회원 등급 추가 할인
    Money membershipDiscount = calculateDiscount(orderer.getMember());
    
    // 실제 결제 금액 계산
    return totalAmounts.minus(discount).minus(membershipDiscount);
  }
}
```

그런데 만약 `특별 감사 세일로 전 품목에 대해 한 달간 2% 추가 할인`을 하기로 한다고 해보겠습니다.

이 할인 정책은 주문 애그리거트가 갖고 있는 구성요소와는 관련이 없음에도 불구하고 `결제 책임이 주문 애그리거트`에 있다는 이유로 `주문 애그리거트 코드를 수정`해야합니다.

그래서 **한 애그리거트에 넣기 애매한 도메인 기능을 억지로 특정 애그리거트에 구현하면 안 됩니다.**

억지로 구현하면 아래와 같은 문제가 발생합니다.
- 애그리거트가 자신의 책임 범위를 넘어서는 기능을 구현
- 코드가 길어지고 외부에 대한 의존이 높아짐
- 코드를 복잡하게 만들어서 수정을 어렵게 만든다.
- 애그리거트의 범위를 넘어서는 도메인 개념이 숨겨져서 명시적으로 드러나지 않게 된다.

이 문제를 해소하는 가장 쉬운 방법은 바로 **도메인 기능을 별도 서비스로 구현** 하는 것입니다.

---
## 7.2 도메인 서비스
도메인 서비스는 도메인 영역에 위치한 도메인 로직을 표현할 때 사용합니다. 주로 다음 상황에서 도메인 서비스를 사용합니다.
- `계산 로직`: 여러 애그리거트가 필요한 계산 로직이나, 한 애그리거트에 넣기에는 다소 복잡한 계산 로직
- `외부 시스템 연동이 필요한 도메인 로직`: 구현하기 위해 타 시스템을 사용해야 하는 도메인 로직

### 7.2.1 계산 로직과 도메인 서비스
할인 금액 규칙 계산처럼 한 애그리거트에 넣기 애매한 개념을 구현하려면 도메인 서비스를 이용해서 개념을 명시적으로 드러내면 됩니다.
> 응용 서비스가 응용 로직을 다룬다면, 도메인 서비스는 도메인 로직을 다룬다.

도메인 영역의 `애그리거트나 벨류`와, `도메인 서비스`와의 다른 점은 도메인 서비스는 `상태 없이 로직만 구현한다는 점`입니다. 도메인 서비스를 구현하는 데 필요한 상태는 다른 방법으로 전달받습니다.

아래는 할인 금액 계산 로직을 위한 도메인 서비스입니다.
```java
public class DiscountCalculationService {
  // 도메인의 의미가 드러나는 용어를 타입과 메서드 이름으로 갖는다.
  public Money calculateDiscountAmounts(List<OrderLine> orderLines, List<Coupon> coupons, MemberGrade grade) {
    
    Money couponDiscount = calculateDiscounts(coupons);
    Money membershipDiscount = calculateDiscount(orderer.getMember().getGrade());
    
    return couponDiscount.add(membershipDiscount);
  }
}
```

위 서비스를 사용하는 주체는 애그리거트가 될 수도 있고 응용 서비스가 될 수도 있습니다.

```java
public class Order {
  private Orderer orderer;
  private List<OrderLine> orderLines;
  private List<Coupon> coupons;

  private void calculatePayAmounts(DiscountCalculationService service, MemberGrade grade) {

    Money totalAmounts = getTotalAmounts();
    
    // 할인 계산 서비스 사용
    Money discountAmounts = service.calculateDiscountAmounts(this.orderLines, this.coupons, grade);
    
    // 결제 금액 세팅
    this.paymentsAmounts = totalAmounts.minus(discountAmounts);
  }
}
```
> 위 처럼 애그리거트의 결제 금액 계산 기능에 전달하면 사용 주체는 애그리거트가 됩니다. 이 때 애그리거트 객체에 도메인 서비스를 전달하는 것은 응용 서비스의 책임입니다.

```java
public class OrderService {
  
  private DiscountCalculationService discountCalculationService;
  
  @Transactional
  public OrderNo placeOrder(OrderRequest request) {
    OrderNo orderNo = orderRepository.nextId();
    Order order = createOrder(orderNo, request);
    orderRepository.save(order);
    return orderNo;
  }
  
  private Order createOrder(OrderNo orderNo, OrderRequest request) {
    Member member = findMember(request.getOrdererId());
    Order order = new Order( ... );
    
    // 응용 서비스에서 애그리거트 객체에 도메인 서비스를 전달한다.
    order.calculateAmounts(this.discountCalculationService, member.getGrade());
    return order;
  }
}
```

---
### 💡 NOTE: 도메인 서비스 객체를 애그리거트에 주입하지 않기
위에서 보다시피 애그리거트의 메서드에 도메인 서비스 객체를 파라미터로 전달하는 것을 볼 수 있습니다.

스프링 DI와 AOP를 공부하다 보면 이런 의존하는 상황을 `의존 주입(DI)`으로 처리하고 싶을 수 있습니다.

하지만 책의 저자께서는 이 방법은 좋은 방법이 아니라고 생각하신다고 합니다.(아래가 그 이유입니다.)

만약 `Order`가 `DiscountCalculationService`를 주입 받는 예시로 보자면,

보통 도메인 객체는 필드로 구성된 데이터와 메서드를 이용해서 개념적으로 하나의 모델을 표현합니다.

그런데, DiscountCalculationService 같은 경우는 Order와 관련된 데이터 자체와는 관련이 없고, Order 객체를 DB에 저장할 때의 대상도 아닙니다.

또한 일부 기능에서만 해당 서비스를 필요로 하기 때문에 굳이 의존 주입할 이유는 없습니다.

따라서 이 상황에서의 의존 주입은 프레임워크의 기능을 사용하고 싶은 개발자의 욕심에 불과합니다.

---


방금까지는 `애그리거트의 메서드에 도메인 서비스를 인자로 전달하는 상황` 이었지만, 반대인 상황도 있습니다.

바로 `도메인 서비스에 애그리거트를 전달하는 상황`입니다.

예시로는 `계좌 이체 기능`을 들 수 있습니다.

```java
// 계좌 이체 도메인 서비스
public class TransferService {
  
  public void transfer(Account fromAcc, Account toAcc, Money amounts) {
    fromAcc.withdraw(amounts);
    toAcc.credit(amounts);
  }
}
```

응용 서비스는 두 Account 애그리거트를 구한 뒤에 해당 도메인 영역의 `TransferService`를 이용할 것입니다.

> 도메인 서비스는 도메인 로직을 수행합니다. 트랜잭션 처리와 같은 로직은 응용 로직이므로 응용 서비스에서 처리해야합니다.
> 
> 💡 도메인 서비스와 응용 서비스 구분하는 방법
> - 해당 로직이 애그리거트의 상태를 변경하면 도메인 로직
> - 도메인 로직이면서 한 애그리거트에 넣기에 적합하지 않으면 도메인 서비스로 구현

### 7.2.2 외부 시스템 연동과 도메인 서비스
`외부 시스템이나 타 도메인과의 연동 서비스 또한 도메인 서비스가 될 수 있습니다.`

아래의 두 시스템이 있다고 해보겠습니다.
- 설문 조사 시스템
- 사용자 권한 관리 시스템
  - 권한 확인

사용자가 설문 조사를 생성할 때 `사용자 권한 관리 시스템`과 연동해야하는 상황입니다.

![시스템 두개.png](image%2F%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EB%91%90%EA%B0%9C.png)

시스템 간 연동은 HTTP API 호출로 이루어질 수 있지만, `설문 조사 시스템 입장`에서는 사용자 권한을 검사하는 도메인 로직으로 볼 수 있습니다.

따라서 다음과 같이 도메인 서비스로 표현할 수 있습니다.

```java
public interface SurveyPermissionChecker {
  boolean hasUserCreationPermission(String userId);
}
```

여기서 중요한 점은 `도메인 로직 관점에서의 인터페이스`로 작성되었다는 점입니다.(`역할 관리 시스템과 연동한다는 관점의 인터페이스`가 아니다!)
> 역할 관리 시스템을 추상화한 것이 아닌, 도메인 로직을 추상화한 느낌. 정도로 이해했습니다.

응용 서비스는 아래와 같이 사용하게 됩니다.
```java
public class CreateSurveyService {
  private SurveyPermissionChecker permissionChecker;
  
  public Long createSurvey(CreateSurveyRequest req) {
    validate(req);
    
    if (!permissionChecker.hasUserCreationPermission(req.getRequestorId())) {
      throw new NoPermissionException();
    }
  }
}
```

위 인터페이스를 구현한 클래스는 `인프라 영역`에 위치시키며, 연동을 포함한 권한 검사 기능을 구현하도록 합니다.

---
### 7.2.3 도메인 서비스의 패키지 위치

![7-1.png](image%2F7-1.png)

도메인 서비스는 도메인 로직을 포함하므로 다른 도메인 구성요소와 같은 패키지에 위치시킵니다.
> e.g) DiscountCalculationService 를 Order 애그리거트와 같은 위치에 둔다.

만약 도메인 서비스의 개수가 많거나 엔티티나 VO와 명시적으로 구분하고 싶다면, 아래와 같이 패키지를 구분해도 좋습니다.
- domain.model
- domain.service
- domain.repository

---

### 7.2.4 도메인 서비스의 인터페이스와 클래스
도메인 서비스의 로직이 고정되어 있지 않다면, 인터페이스를 구현하게 될 수 있습니다.

특히 아래와 같은 상황에서 발생합니다.
- 외부 시스템 이용
- 별도 엔진 이용

이 때는 인터페이스는 도메인 영역에, 구현 클래스는 인프라 영역에 위치시킵니다.

![7-2.png](image%2F7-2.png)

이렇게 추상화를 함으로써 도메인 영역이 특정 구현에 종속되는 것을 방지할 수 있고 도메인 영역에 대한 테스트가 쉬워집니다.