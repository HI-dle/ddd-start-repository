# 5.5 스펙 조합
스프링 데이터 JPA가 제공하는 스펙 인터페이스는 스펙을 조합할 수 있는 and 와 or 라는 두 메서드를 제공한다.

### and() 와 or()
- 기본 구현을 가진 디폴트 메서드이다. 
- and () 메서드는 두 스펙을 모두 충족하는 조건을 표현하는 스펙을 생성한다. 
- or() 메서드는 두 스펙 중 하나 이상 충족하는 조건을 표현하는 스펙을 생성한다. 

```java
public interface Specification<T> extends Serializable {

    //...생략
    default Specification<T> and(@Nullable Specification<T> other) { ... }
    default Specification<T> or(@Nullable Specification<T> other) { ... }
    
    @Nullable
    Predicate toPredicate(Root<T> root, CriteriaQuery<?> query, CriteriaBuilder criteriaBuilder);
}
```

### 예 
- spec1.and (spec2)는 spec1과 spec2를 모두 충족하는 조건을 표현하는 spec3을 생성한다.
```java
Specification OrderSummary> spec1 = OrderSummarySpecs.ordererId("user1");
Specification<OrderSummary> spec2 = OrderSummarySpecs.orderDateBetween(
LocalDateTime.of(2022, 1, 1, 0, 0, 0),
LocalDateTime.of (2022, 1, 2, 0, 0, 0));
Specification<OrderSummary> spec3 = spec1.and(spec2);
```

- 개별 스펙 조건마다 변수를 선언하지 않아도 된다. 
- 아래처럼 바로 and () 메서드를 사용하면 불필요한 변수 사용을 줄일 수 있다.
```java
Specification<OrderSummary> spec = OrderSummarySpecs.ordererId ("user1")
                                            .and (OrderSummarySpecs.orderDateBetween(from, to));
```

### not()
- not()은 정적 메서드로 조건을 반대로 적용할 때 사용한다. 

### nullable
null 가능성이 있는 스펙 객체와 다른 스펙을 조합해야 할 때가 있다. 이 경우 null 여부를 판단해서 NullPointerException이 발생하는 것을 방지할 수 있다.
```java
Specification OrderSummary> nullableSpec = createNullableSpec(); // null일 수 있음
SpecificationOrderSummary> otherSpec = create0therSpeс();
Specification OrderSummary> spec =
         nullableSpec = = null? otherSpec: nullableSpec.and (otherSpec);
```

### where
where () 메서드를 사용하면 null 확인의 귀찮음을 줄일 수 있다. 
- where () 메서드는 스펙 인터페이스의 정적 메서드로 null을 전달하면 아무 조건도 생성하지 않는 스펙 객체를 리턴하고 null이 아니면 인자로 받은 스펙 객체를 그대로 리턴한다.
```java
Specification<OrderSummary> spec = 
        Specification.where(createNullableSpec()).and(create0therSpec());
```

# 5.6 정렬 지정하기

### 스프링 데이터 JPA 의 정렬 지정 방식 2가
1. 메서드 이름에 OrderBy를 사용해서 정렬 기준 지정
2. Sort를 인자로 전달

### 1.
- 특정 프로퍼티로 조회하는 find 메서드는 이름 뒤에 OrderBy를 사용해서 정렬 순서를 지정할
수 있다. 
```java
public interface OrderSummaryDao extends Repository OrderSummary, String> {
    List OrderSummary> findByOrdererIdOrderByNumberDesc(String ordererId);
}
```

- findByOrdererIdOrderByNumberDesc 메서드는 다음 조회 쿼리를 생성한다.
    - ordererld 프로퍼티 값을 기준으로 검색 조건 지정
    - number 프로퍼티 값 역순으로 정렬

- 두 개 이상의 프로퍼티에 대한 정렬 순서를 지정할 수도 있다. 
```java
findByOrdererIdOrderByOrderDateDescNumberAsc
```
위 메서드는 먼저 OrderDate 프로퍼티를 기준으로 내림차순으로 정렬하고 다음에 Number 프로퍼티를 기준으로 오름차순으로 정렬하는 쿼리를 생성한다.

### 2.
- 메서드 이름에 OrderBy를 사용하는 방법은 간단하지만 정렬 기준 프로퍼티가 두 개 이상이면 메서드 이름이 
길어지는 단점이 있다. 
- 또한 메서드 이름으로 정렬 순서가 정해지기 때문에 상황에 따라 정렬 순서를 변경할 수도 없다. 이럴 때는 Sort 타입을 사용하면 된다.
- 스프링 데이터 JPA는 정렬 순서를 지정할 때 사용할 수 있는 Sort 타입을 제공한다.
    - 스프링 데이터 JPA는 파라미터로 전달 받은 Sort를 사용해서 알맞게 정렬 쿼리를 생성한다. 
    - find 메서드를 사용하는 코드는 알맞은 Sort 객체를 생성해서 전달하면 된다.

```java
import org.springframework.data.domain.Sort;

public interface OrderSummaryDao extends Repository OrderSummary, String> {
    List<OrderSummary> findByOrdererId(String ordererId, Sort sort);
    List OrderSummary> findAll(Specification<OrderSummary> spec, Sort sort);
```

- Sort의 사용법
    - "number" 프로퍼티 기준 오름차순 정렬을 표현하는 sort 객체를 생성한다.
```java
Sort sort = Sort.by("number").ascending ();
List OrderSummary> results = orderSummaryDao.findBy0rdererId("user1", sort);
```

- 두 개 이상의 정렬 순서를 지정하고 싶다면 Sort#and () 메서드를 사용해서 두 Sort 객체를 연결하면 된다.
```java
Sort sort1 = Sort.by("number").ascending);
Sort sort2 = Sort.by("orderDate").descending);
Sort sort = sort1.and(sort2);

// 더 짧게
Sort sort = Sort.by("number").ascending().and(Sort.by("orderDate").descending());
```