# 5.8 스펙 조합과 동적 인스턴스 생성

## 스펙(Specification) 조합 문제점

```java
Specification<MemberData> spec = Specification.where(null);

if (searchRequest.isOnlyNotBlocked()) {
    spec = spec.and(MemberDataSpecs.nonBlocked());
}
if (StringUtils.hasText(searchRequest.getName())) {
    spec = spec.and(MemberDataSpecs.nameLike(searchRequest.getName()));
}
List<MemberData> result = memberDataDao.findAll(spec, PageRequest.of(0, 5));
```

- 조건 분기(`if`)와 스펙 조합 코드가 섞여 있어 **복잡하고 실수하기 쉽다**.

---

## 개선된 방식: SpecBuilder 사용

### 사용 예

```java
Specification<MemberData> spec = SpecBuilder.builder(MemberData.class)
    .ifTrue(searchRequest.isOnlyNotBlocked(),
        () -> MemberDataSpecs.nonBlocked())
    .ifHasText(searchRequest.getName(),
        name -> MemberDataSpecs.nameLike(searchRequest.getName()))
    .toSpec();

List<MemberData> result = memberDataDao.findAll(spec, PageRequest.of(0, 5));
```

### SpecBuilder 구현

```java
package com.rouby.routine;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;
import java.util.function.Supplier;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.util.StringUtils;

public class SpecBuilder {
  public static <T> Builder<T> builder(Class<T> type) {
    return new Builder<T>();
  }

  public static class Builder<T> {
    private List<Specification<T>> specs = new ArrayList<>();

    public Builder<T> and(Specification<T> spec) {
      specs.add(spec);
      return this;
    }

    public Builder<T> ifHasText(String str, Function<String, Specification<T>> specSupplier) {
      if (StringUtils.hasText(str)) {
        specs.add(specSupplier.apply(str));
      }
      return this;
    }

    public Builder<T> ifTrue(Boolean cond, Supplier<Specification<T>> specSupplier) {
      if (cond != null && cond) {
        specs.add(specSupplier.get());
      }
      return this;
    }

    public Specification<T> toSpec() {
      Specification<T> spec = Specification.where(null);
      for (Specification<T> s : specs) {
        spec = spec.and(s);
      }
      return spec;
    }
  }
}
```

코드 양은 비슷하지만 메서드를 사용하여 조건을 표현하고 메서드 호출 체인으로 연속된 변수 할당을 줄여 가독성이 향상 되고 구조가 단순해진다

---

# 5.9 동적 인스턴스 생성 

JPA는 JPQL에서 **생성자 기반 객체 생성**을 지원함:

```java
public interface OrderSummaryDao extends Repository<OrderSummary, String> {
  @Query("""
    select new com.myshop.order.query.dto.OrderView(
      o.number, o.state, m.name, m.id, p.name
    )
    from Order o join o.orderLines ol, Member m, Product p
    where o.orderer.memberId.id = :orderId
      and o.orderer.memberId.id = m.id
      and index(ol) = 0
      and ol.productId.id = p.id
    order by o.number.number desc
  """)
  List<OrderView> findOrderView(String ordererId);
}
```

- `select new` 문법은 **지정된 생성자를 이용해 인스턴스를 생성**함.
- 조회 전용 모델(`OrderView`)을 별도로 정의.

### 조회 전용 모델 예

```java
public class OrderView {
  private final String number;
  private final OrderState state;
  private final String memberName;
  private final String memberId;
  private final String productName;

  public OrderView(OrderNo number, OrderState state,
                   String memberName, MemberId memberId,
                   String productName) {
    this.number = number.getNumber();
    this.state = state;
    this.memberName = memberName;
    this.memberId = memberId.getId();
    this.productName = productName;
  }

  // getter 생략
}
```

---

## 조회 전용 모델 사용 이유

- **표현 영역(View Layer)** 에 맞는 **데이터 포맷을 제공**하기 위함.
- 많은 웹 프레임워크가 새로 추가한 밸류 타입(Money, Quantity 등)을 제대로 출력하지 못하는 경우가 많음 → **기본 타입으로 변환**하여 반환.
- 프레임워크에 익숙하다면 밸류 타입을 원하는 형식으로 출력하도록 프레임 워크를 확장하여 조회 전용 모델에서 **값 객체의 의미를 유지**할 수 있음.

---

## JPQL 동적 인스턴스 생성의 장점

- **JPQL 기반**으로 객체 지향적 쿼리 작성 가능.
- **지연/즉시 로딩 고민 없이** 원하는 형태로 데이터 조회 가능.

---
