# 5.10 하이버네이트 @Subselect 사용

하이버네이트는 JPA 확장기능으로 @Subselect를 제공한다.
- @Subselect 는 쿼리 결과를 @Entity로 매핑할 수 있는 기능을 말한다.

## 예시
```java
//하이버네이트 의존성
import org.hibernate.annotations.Immutable;
import org.hibernate.annotations.Subselect;
import org.hibernate.annotations.Synchronize;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import java.time.LocalDateTime;

@Entity
@Immutable // 읽기 전용 엔티티로, 변경 감지 및 쓰기(insert/update/delete) 불가 (더티체킹 무시)
@Subselect(
    """
    select o.order_number as number,
           o.version,
           o.orderer_id, o.orderer_name,
           o.total_amounts, o.receiver_name, o.state, o.order_date,
           p.product_id, p.name as product_name
    from purchase_order o
    inner join order_line ol on o.order_number = ol.order_number
    cross join product p
    where ol.line_idx = 0
      and ol.product_id = p.product_id
    """
) // 해당 엔티티에 매핑 될 쿼리 결과, 정적 SELECT 결과를 기반으로 가상 테이블처럼 매핑됨 (읽기 전용 뷰)
@Synchronize({"purchase_order", "order_line", "product"}) // 해당 테이블들에 변경이 발생하면 이 엔티티의 결과를 가져오기 전에 먼저 flush 한다.
public class OrderSummary {

    @Id
    private String number;

    private long version;

    @Column(name = "orderer_id")
    private String ordererId;

    @Column(name = "orderer_name")
    private String ordererName;

    @Column(name = "total_amounts")
    private int totalAmounts;

    @Column(name = "receiver_name")
    private String receiverName;

    private String state;

    @Column(name = "order_date")
    private LocalDateTime orderDate;

    @Column(name = "product_id")
    private String productId;

    @Column(name = "product_name")
    private String productName;

    protected OrderSummary() {
    }
}

```

- `@Immutable`, `@Subselect`, `@Synchronize`는 하이버네이터 전용 애너테이션이며, 이를 사용하면 테이블이 아닌 쿼리 결과를 `@Entity`로 매핑할 수 있다.

### @Subselct

- `@Subselect`는 조회 쿼리를 값으로 갖는다. 하이버네이트는 이 select 쿼리의 결과를 매핑할 테이블처럼 사용한다.
    - DBMS의 뷰와 비슷하게 동작한다.
    - 뷰란 데이터베이스에 존재하는 일종의 **가상 테이블**을 말하며, 중복적으로 사용되는 Select 문의 결과를 저장해두는 것으로 이해하면 될 듯 하다.

### @Immutable

- 뷰를 수정할 수 없듯이, 해당 엔티티 역시 수정할 수 없다. 만약 수정하면 하이버네이트는 변경 내역을 반영하는 update 쿼리를 실행할 것이다. 하지만 실제 존재하는 테이블이 없으므로 에러가 발생한다.
- 이런 문제를 방지하기 위해 `@Immutable` 을 사용한다.
    - 이를 사용하면 하이버네이트는 해당 엔티티의 매핑 필드, 프로퍼티가 변경되어도 DB에 반영하지 않고 무시한다.

### @Synchronize
```java
// purchase_order 테이블에서 조회
Order order = orderRepository.findById(orderNumber);
order.changeShippingInfo(newInfo); // 상태 변경

// 변경 내역이 DB에 반영되지 않았는데 purchase_order 테이블에서 조회
List<OrderSummary> summaries = orderSummaryRepository.findByOrdererId(userId);
```

- 위 코드는 Order의 상태를 변경한 후에 OrderSummary (@Subselect 엔티티) 를 조회하고있다.
- 특별한 이유가 없으면 하이버네이트는 트랜잭션을 커밋하는 시점에 변경사항을 DB에 반영하므로, Order의 변경 내역을 실제 테이블에 반영하지 않은 상태에서 해당 테이블을 사용하는 OrderSummary를 조회하게 된다. 즉, OrderSummary에는 변경이 반영되지 않은 이전 값이 담기게 된다.
- 이런 문제를 해소하기 위한 용도로 사용한 것이 바로 `@Synchronize` 이다.
    - 이는 해당 엔티티와 관련된 테이블 목록을 명시한다.
    - 하이버네이트는 엔티티를 로딩하기 전에 지정한 테이블과 관련된 변경이 발생하면 flush를 먼저한다.
- OrderSummary의 `@Synchronize`는 purchase_order 테이블에 변경이 발생하면 관련 내역을 먼저 플러시 한다.
    - 따라서 OrderSummary 를 로딩하는 시점에는 변경 내역이 반영된다.


### @Entity

- `@Subselect` 를 사용해도 일반 @Entity와 같기 때문에 EntityManager의 메서드, JPQL, Criteria를 사용해서 조회할 수 있다.
- 초반에 설명한 Spec 을 사용할 수 있다는 것도 포함한다.

```java
// @Subselect를 적용한 @Entity는 일반 @Entity와 동일한 방법으로 조회할 수 있다.
Specification<OrderSummary> spec = orderDateBetween(from, to);
Pageable pageable = PageRequest.of(1, 10);
List<OrderSummary> results = orderSummaryDao.findAll(spec, pageable);
```

### 실제 쿼리

- @Subselct는 이름처럼 @Subselect로 지정한 쿼리를 from 절의 서브 쿼리로 사용한다.

```sql
select osm.number as number1_0_, ...생략
from (
    select o.order_number as number,
           o.version,
           ...생략
           p.name as product_name
    from purchase_order o
        inner join order_line ol on o.order_number = ol.order_number
        cross join product p
    where ol.line_idx = 0
      and ol.product_id = p.product_id
) osm
where osm.orderer_id = ?
order by osm.number desc

```

- @Subselect를 사용할 때는 쿼리가 이런 형태를 갖는다는 점을 유념해야한다.
- 서브쿼리를 사용하고 싶지 않다면 네이티브 SQL 쿼리를 사용하거나, 마이바티스와 같은 별도 매퍼를 사용해서 조회 기능을 구현해야 한다.