# 도메인 모델과 바운디드 컨텍스트

---


## 9.4 바운디드 컨텍스트 간 통합

- 온라인 쇼핑 사이트에서 매출 증대를 위해 카탈로그 하위 도메인에 개인화 추천 기능을 도입한다고 하자.
  - 기존 카탈로그 시스템을 개발하던 팀과 별도로 추천 시스템을 담당하는 팀이 생겨 이 팀에서 주도적으로 추천 시스템을 만들기로 했다.
    - 그렇다면 카탈로그 하위 도메인에는 기존 카탈로그를 위한 바운디드 컨텍스트와 추천 기능을 위한 바운디드 컨텍스트가 생긴다.

![image_9_10.png](image%2Fimage_9_10.png)

 - 두 팀이 관련되 바운디드 컨텍스트를 개발하면 자연스럽게 두 바운디드 컨텍스트 간 통합이 발생한다.
   -  카탈로그와 추천 바운디드 컨텍스트 간 통합이 필요한 기능은 "사용자가 제품 상세 페이지를 볼 때, 보고 있는 상품과 유사한 상품 목록을 하단에 보여준다." 이다.

 - 사용자가 카탈로그 바운디드 컨텍스트에 추천 제품 목록을 요청하면 카탈로그 바운디드 컨텍스트는 추천 바운디드 컨텍스트로부터 추천 정보를 읽고 추천 제품 목록을 제공한다.
 - 카탈로그 컨텍스트와 추천 컨텍스트의 도메인 모델은 서로 다르다.
 - 카탈로그는 제품을 중심으로 도메인 모델을 구현하지만 추천은 추천 연산을 위한 모델을 구현한다.
   - 추천 시스템은 상품의 상세 정보를 포함하지 않으며 상품 번호 대신 아이템 ID를 사용해 식별자를 표현하고 추천 순와 같은 데이터를 담게 된다.
 - 카탈로그 시스템은 추천 시스템으로부터 추천 데이터를 받아오지만 카탈로그 시스템에서는 추천의 도메인 모델을 사용하기 보단 카탈로그 도메인 모델을 사용해 추천 상품을 표현해야 한다.

```Java

// 상품 추천 기능을 표현하는 도메인 서비스
public interface ProductRecommendationService {
  List<Product> getRecommendationsOf(ProductId id);
}
```

 - 도메인 서비스를 구현한 클래스는 인프라스트럭쳐 영역에 위치하고 이 클래스는 외부 시스템과 연동을 처리하며, 외부 시스템의 모델과 현재 도메인 모델 간의 변환을 책임진다.

![image_9_11.png](image%2Fimage_9_11.png)

 - 외부 연동을 위해 도메인 서비스 구현 클래스는 도메인 모델과 외부 시스템 간 모델 변환을 처리

 - RecSystemClient는 외부 추천 시스템이 제공한느 REST API를 통해 특정 상품을 위한 추천 상품 목록을 로딩한다.
 - 이 REST API가 제공하는 데이터는 추천 시스템의 모델을 기반하기 때문에 API 응답은 카탈로그 도메인 모델과 일치하지 않는 데이터를 제공할 것이다.

```Json
[
  {
    itemId: 'PROD-1000',
    type: 'PRODUCT',
    rank: 100
  },{
    itemId: 'PROD-1001',
    type: 'PRODUCT',
    rank: 54
  },
]
```

 - RecSystemClient는 데이터를 읽어와 카탈로그 도메인에 맞는 상품 모델로 변환해야한다.

```java
//해당 응답을 꺼내 field에 맞는 데이터로 매핑
private List<Product> toProducts(List<RecommendationItem> items){
  return items.stream()
      .map(item -> toProductId(item.getItemId()))
      .map(prodId -> productRepository.findById(prodId))
      .collect(toList());
}
```
 - 외부 시스템과 연동에서 맞지 않는 데이터를 서비스 내부에 알맞은 모듈로 변환해 모델을 맞춰야 한다.
 - 위에서는 추천 시스템의 모델을 받아 카탈로그 도메인의 Product 모델로 변환하는 작업을 처리한다.
 - 만약 두 모델간 변환이 복잡하다면 변환 처리를 위한 별도의 클래스를 만들어 변환의 책임을 위임해도 된다.

![image_9_12.png](image%2Fimage_9_12.png)


 - REST API를 호출하는 것은 두 바운디드 컨텍스트를 직접 통합하는 방법으로 직접 통합 대신 간접 통합하는 방법도 있다.
 - 대표적인 간접 통합 방식은 메시지 큐를 사용하는 것으로 추천시스템은 사용자가 조회한 상품 이력이나 구매 이력과 같은 사용자 활동 이력을 필요로 하는데 이 내역을 전달할 때 메시지 큐를 사용할 수 있다.

![image_9_13.png](image%2Fimage_9_13.png)

### 메시지 구조 합의 필요성

 - 카탈로그 바운디드 컨텍스트는 추천 시스템이 필요로 하는 사용자 활동 이력을 메시지 큐에 추가한다.
 - 메시지 큐는 비동기로 메시지를 처리하기 때문에 카탈로그 바운디드 컨텍스트는 메시지를 큐에 추가한 뒤 추천 바운디드 컨텍스트가 메시지를 처리할 때까지 기다리지 않고 자신의 처리를 이어하게 된다.
 - 추천 바운디드 컨텍스트는 큐에서 이력 메시지를 읽어와 추천을 계산하는 데 사용한다.

 ➡️ 두 바운디드 컨텍스트가 사용할 메시지의 데이터 구조를 맞춰야 함을 의미한다.(데이터 형식에 대해 협의 필요)
 
 메시지 시스템을 
 - 카탈로그 측에서 관리하고 있다면 큐에 담기는 메시지는 카탈로그 도메인을 따르는 데이터를 담을 것이다.
   - ![img.png](image/9-14.png) 
 - 추천 바운디드 컨텍스트 관점에서 접근하면 아래와 같이 메시지 데이터 구조를 잡을 수 있다.
   - ![img_1.png](image/9_15.png)

### 큐 제공 주체에 따른 메시지 구조
어떤 도메인 관점에서 모델을 사용하느냐에 따라 두 바운디드 컨텍스트의 구현 코드가 달라지게 된다. 

#### 1. 카탈로그 시스템이 큐를 제공하는 경우
- 큐에 담기는 메시지는 카탈로그 도메인 모델을 따른다.
- 카탈로그 측 코드는 도메인 데이터를 그대로 메시지 큐에 저장한다.
- 추천 시스템은 자신의 모델에 맞게 변환하여 처리한다.
```java
// 상품 조회 관련 로그 기록 코드
public class ViewLogService {

  private MessageClient messageClient;

  public void appendViewLog(String memberId, String productId, Date time) {
    messageClient.send(new ViewLog(memberId, productId, time));
  }
}

// messageClient
public class RabbitMQClient implements MessageClient {

  private RabbitTemplate rabbitTemplate;

  @Override
  public void send(ViewLog viewLog) {
// 카탈로그 기준으로 작성한 데이터를 큐에 그대로 보관
    rabbitTemplate.convertAndSend(logQueueName, viewLog);
  }
}
```

#### 2. 추천 시스템이 큐를 제공하는 경우
반대로 추천 시스템을 기준으로 큐에 데이터를 저장하기로 했다면 카탈로그 쪽 코드는 다음과 같이 바뀔 것이다.

- 큐에 담기는 메시지는 추천 도메인 모델을 따른다.
- 카탈로그 측은 추천 시스템 기준의 메시지 구조로 변환하여 전송한다.
```java
// 상품 조회 관련 로그 기록 코드
public class ViewLogService {

  private MessageClient messageClient;

  public void appendViewLog(String memberId, String productId, Date time) {
    messageClient.send(
        new ActivityLog(productId, memberId, ActivityType.VIEW, time));
  }
}
// messageClient
public class RabbitMQClient implements MessageClient {

  private RabbitTemplate rabbitTemplate;

  @Override
  public void send(ActivityLog activityLog) {
    rabbitTemplate.convertAndSend(logQueueName,activityLog);
  }
}
```
### 데이터 구조 결정
- 큐 제공자가 누구냐에 따라 메시징 모델이 달라진다.
  - 카탈로그에서 제공 시:
    - 큐에 담기는 데이터는 카탈로그 도메인을 따름 
    - 카탈로그는 메시지를 발행(publish)
    - 추천 시스템은 메시지를 구독(subscribe)
    - → 출판/구독 모델을 따름
      - ![img.png](image/9-16.png)
  - 추천 시스템 제공 시:
    - 큐를 통해 메시지를 추천 시스템에 전달하는 방식
      - 큐를 통해 전달되는 메시지는 사실상 REST API 호출과 유사
        - 차이점은 비동기 처리라는 점뿐

### Note. 마이크로서비스와 바운디드 컨텍스트

- 마이크로서비스 아키텍처가 단순 유행을 지나 많은 기업에서 자리를 잡아가고 있다. 
  - 넷플릭스나 아마존 같은 선도 기업뿐 아닌 많은 기업이 마이크로서비스 아키텍처를 수용
- 마이크로서비스 아키텍처: 애플리케이션을 작은 서비스로 분리 개발하는 아키텍처 스타일, REST API나 메시징으로 통신.
- 바운디드 컨텍스트와 자연스럽게 어울린다:
  - 각 바운디드 컨텍스트는 독립적인 모델 경계를 형성 
  - 바운디드 컨텍스트를 마이크로서비스로 구현하면 코드와 모델이 분리되어 혼합되지 않음
  - 별도 프로세스로 개발한 바운디드 컨텍스트 → 독립 배포, 모니터링, 확장 가능 (= 마이크로서비스 특징)



