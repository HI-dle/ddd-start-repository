# 10.5 비동기 이벤트 처리

## 'A하면 이어서 B하라'는 'A하면 최대 언제까지 B하라'인 경우가 많다.
- `회원가입 검증 이메일 발송`: 바로가 아닌 몇 초 뒤에 도착해도 상관없음
- `주문 취소 후에 결제 취소`: 결국 결제 취소가 이루어지면 됨
- 또한, B를 하는 데 실패하면 일정 간격으로 재시도를 하거나 수동 처리를 해도 상관없는 경우가 존재
   - e.g 이메일 발송 실패: 사용자가 이메일 재전송 요청을 이용하여 수동으로 다시 받아볼 수 있음

## 'A하면 일정 시간 안에 B하라' 에서 'A하면'은 이벤트로 볼 수도 있다.
- '회원가입 신청'을 하면 '인증 이메일을 보내라': `회원 가입 신청 이벤트`를 처리하는 핸들러에서 `인증 이메일 전송`

> `'A하면 이어서 B하라'`라는 요구사항 중에서 `'A하면 최대 언제까지 B하라'`로 바꿀 수 있는 요구사항은 `이벤트를 비동기로 처리`하는 방식으로 구현할 수 있다.

---
## 이벤트를 비동기로 구현할 수 있는 방법 네가지
- 로컬 핸들러를 비동기로 실행하기
- 메시지 큐를 사용하기
- 이벤트 저장소와 이벤트 포워더 사용하기
- 이벤트 저장소와 이벤트 제공 API 사용하기

> 각 방법의 구현 방식과 장단점을 알아보자.

### 10.5.1 로컬 핸들러 비동기 실행
이벤트 핸들러를 비동기로 실행하는 방법은 `이벤트 핸들러를 별도 스레드로 실행`하는 것입니다.
- 스프링에서 제공하는 `@Async` 애노테이션을 사용하면 손쉽게 비동기로 이벤트 핸들러를 실행할 수 있다.
  - `@EnableAsync`를 통해 비동기 기능 활성화
  - 이벤트 핸들러 메서드에 `@Async` 애노테이션 붙이기

```java
@SpringBootApplication
@EnableAsync // 비동기 기능 활성화, 스프링 설정 클래스에 붙이면 된다.
public class ShopApplication {
  
  public static void main(String[] args) {
    SpringApplication.run(ShopApplication.class, args);
  }
}

// ---

@Service
public class OrderCanceledEventHandler {
  
  @Async // 비동기로 실행할 이벤트 핸들러 메서드에 붙인다.
   @EventListener(OrderCanceledEvent.class)
   public void handle(OrderCanceledEvent event) {
    refundService.refund(event.getOrderNumber());
  }
}

// 스프링은 OrderCanceledEvent가 발생하면 handle() 메서드를 별도 스레드를 이용해서 비동기로 실행한다.
```

---
### 10.5.2 메시징 시스템을 이용한 비동기 구현
비동기로 이벤트를 처리하는 또 다른 방법은 `카프카나 레빗MQ와 같은 메시징 시스템을 사용`하는 것입니다.

![10-8.png](image%2F10-8.png)
- 이벤트 발생
- `이벤트 디스페처`가 `메시지 큐`로 전송
- `메시지 큐`는 `메시지 리스너`에게 전달
- `메시지 리스너`는 `알맞은 이벤트 핸들러를 이용해서 이벤트 처리`

> 이 때, `이벤트를 메시지 큐에 저장하는 과정`과 `메시지 큐에서 이벤트를 읽어와 처리하는 과정`은 `별도 스레드나 프로세스로 처리`한다.

- 필요하다면, `이벤트를 발생시키는 도메인 기능`과 `메시지 큐에 이벤트를 저장하는 절차`를 한 트랜잭션으로 묶어야한다.
  - 이를 위해서는 `글로벌 트랜잭션`이 필요
    - 이벤트를 안전하게 메시지 큐에 전달할 수 있다는 장점
    - 반면에, 전체 성능이 떨어지는 단점
    - 글로벌 트랜잭션을 지원하지 않는 메시징 시스템 또한 존재


- 메시지 큐를 사용하면 보통 이벤트를 발생시키는 주체와 이벤트 핸들러가 별로 프로세스에서 동작한다.
  - 이는 `이벤트 발생 JVM`과 `이벤트 처리 JVM`이 `다르다`는 것을 의미
  - 하나의 JVM에서 이벤트 발생 주체와 이벤츠 핸들러가 메시지 큐를 이용해서 이벤트를 주고받을 수 있지만, 동일 JVM에서 비동기 처리를 위해 `메시지 큐를 사용하는 것`은 `시스템을 복잡`하게 만든다.
    - (`모놀리식에서 메시지큐를 사용하는 것은 시스템을 복잡하게 만든다는 의미로 이해`했습니다.)


- 메시징 시스템(e.g 래빗MQ와 카프카)
  - 많이 사용되는 메시징 시스템은 `글로벌 트랜잭션` 지원과 함께 `클러스터와 고가용성을 지원`하기 때문에 `안정적으로 메시지를 전달할 수 있는 장점`이 존재
  - 다양한 개발 언어와 통신 프로토콜도 지원
  - 카프카는 글로벌 트랜잭션을 지원하지는 않지만, 다른 메시징 시스템에 비해 높은 성능을 보여줌

---
### 10.5.3 이벤트 저장소를 이용한 비동기 처리
이벤트를 비동기로 처리하는 또 다른 방법은 `이벤트를 일단 DB에 저장한 뒤에 별도 프로그램을 이용해서 이벤트 핸들러에 전달하는 것`입니다.

![10-9.png](image%2F10-9.png)

#### 1. 실행 흐름
- 이벤트 발생
- 핸들러는 스토리지에 이벤트 저장
- 포워더는 주기적으로 스토리지에서 이벤트를 가져와서 이벤트 핸들러를 실행
  - (포워더는 별도 스레드를 이용하기 때문에 이벤트 발행과 처리가 비동기로 처리됨)

이 방식은 `도메인의 상태와 이벤트 저장소로 동일한 DB를 사용`합니다. 즉, `도메인의 상태 변화와 이벤트 저장이 로컬 트랜잭션으로 처리`됩니다.

이벤트를 물리적 저장소에 보관하기 때문에, 핸들러가 이벤트 처리에 실패할 경우 포워더는 다시 저장소에서 이벤트를 읽어와 핸들러를 실행하면 됩니다.

#### 2. 이벤트 저장소를 이용한 두 번째 방법(: 이벤트를 외부에 제공하는 API를 사용)

![10-10.png](image%2F10-10.png)

이벤트 저장소를 이용한 첫 번째 방법(포워더 방식)과의 차이점은 이벤트를 전달하는 방식에 있습니다.
- `포워더 방식`: 포워더를 이용해서 이벤트를 외부에 전달
  - 즉, 이벤트를 어디까지 처리했는지 추적하는 역할이 `포워더`에게 있음
- `API 방식`: 외부 핸들러가 API 서버를 통해 이벤트 목록을 가져감
  - 이벤트를 어디까지 처리했는지를 외부 핸들러 본인이 기억해야함