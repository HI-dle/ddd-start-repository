# 10.1 시스템 간 강결합 문제

- 쇼핑몰의 구매 취소시, 환불을 실행하는 주체는 주문 도메인 엔티티가 될 수 있다.
  이 경우, 도메인 서비스를 파라미터로 전달 받고 취소 도메인 기능에서 도메인 서비스를 실행할 수 있다.

```java
public class Order {
    ...
    // 외부 서비스를 실행하기 위해 도메인 서비스를 파라미터로 전달받음
    public void cancel(RefundService refundService) {
        verifyNotYetShipped();
        this.state = OrderState.CANCELED;

        this.refundStatus = State.REFUND_STARTED;
        try {
            refundService.refund(getPaymentId());
            this.refundStatus = State.REFUND_COMPLETED;
        } catch (Exception ex) {
            ???
        }
    }
}
```

- 응용 서비스에서 환불 기능을 실행할 수도 있다.
```java
public class CancelOrderService {
    private RefundService refundService;

    @Transactional
    public void cancel(OrderNo orderNo) {
        Order order = findOrder(orderNo);
        order.cancel();

        order.refundStarted();
        try {
            refundService.refund(order.getPaymentId());
            order.refundCompleted();
        } catch (Exception ex) {
            ???
        }
    }
}

```
보톨 결제 시스템은 외부에 호출하므로 refundService는 외부 결제시스템이 제공하는 환불 기능을 호출한다. 이 때 두 가지 문제가 발생할 수 있다.
- 트랜잭션: 외부 서비스가 정상이 아닐 경우 트랜잭션 처리를 어떻게 할 것인가? 환불 기능을 실행하는 과정에서 예외 발생시 트랜잭션을 롤백해야 할까 ? 아니면 커밋해야 할까 ?
    - 외부의 환불 서비스를 실행하는 과정에서 익셉션이 발생하면 주문 취소를 롤백할 수 있다.
    - 또는 주문은 취소 상태로 변경하고 환불만 다시 시도할 수도 있다.
- 성능: 환불을 처리하는 외부 시스템의 응답 시간이 길어지면 그만큼 대기 시간도 길어진다. 환불 처리 기능이 30초가 걸리면 주문 취소 기능은 30초만큼 대기 시간이 증가한다. (외부 서비스 성능에 직접적인 영향)

```java
	//외부 결제 시스템이 제공하는 환불 서비스를 트랜잭션 내에서 호출
	//외부 서비스 성능에 직접 영향을 받는다.
	refundService.refund(order.getPaymentId());
```

두 가지 문제 외에 추가로 주문 로직과 결제 로직이 섞이는 설계상 문제가 나타날 수 있다.

```java
public class Order {

    public void cancel(RefundService refundService) {
        // 주문 로직
        verifyNotYetShipped();
        this.state = OrderState.CANCELED;

        // 결제 로직 (다른 도메인 로직이 섞여 있음)
        this.refundStatus = State.REFUND_STARTED;
        try {
            refundSvc.refund(getPaymentId());
            this.refundStatus = State.REFUND_COMPLETED;
        } catch (Exception ex) {
            ...
        }
    }
}

```
주문을 표현하는 도메인 객체 내에 결제 도메인의 환불 로직이 섞이게 된다. 이는 환불 기능이 바뀌면 Order도 영향을 받을 수 있다는 것을 의미한다. (강결합)

추가로 주문 취소 후 환불 뿐 아니라 취소 내용을 통지해야 하는 경우 앞의 문제가 더 커지며 트랜잭션 처리가 더 복잡해진다. 같은 방식으로 처리할 경우, 영향을 주는 외부 서비스가 두 개로 증가한다.

```java
public class Order {
    // 기능을 추가할 때마다 파라미터가 함께 추가되면
    // 다른 로직이 더 많이 섞이고, 트랜잭션 처리가 더 복잡해진다.
    public void cancel(RefundService refundService, NotiService notiSvc) {
        verifyNotYetShipped();
        this.state = OrderState.CANCELED;

        // 주문·결제·통지 로직이 섞임
        // refundService는 성공하고, notiSvc는 실패하면?
        // refundService와 notiSvc 중 무엇을 먼저 처리하나?
    }
}

```

지금까지 언급한 문제가 발생하는 이유는 주문 바운디드 컨텍스트와 결제 바운디드 컨텍스트 간의 *강결합* 때문이다. 주문이 결제와 강하게 결합되어 있어서 주문 바운디드 컨텍스트가 결제 바운디드 컨텍스트에 영향을 받게 되는 것이다.

> 이런 강한 결합을 없앨 수 있는 방법은 이벤트를 사용하는 것이다.
> 특히 비동기 이벤트를 사용하면 두 시스템 간의 결합을 크게 낮출 수 있다.