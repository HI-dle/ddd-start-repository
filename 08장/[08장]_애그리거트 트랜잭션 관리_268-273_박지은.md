## 8.4.2 DB를 이용한 LockManager 구현

DB를 이용한 LockManager를 구현해 보자. 

```sql
create table locks (
    type varchar(255),
    id varchar(255),
    lockid varchar(255),
    expiration_time datetime,
    primary key (type, id)
) character set utf8;

create unique index locks_idx ON locks (lockid);
```

잠금 정보를 저장할 테이블과 인덱스를 생성한다. 

- type + id : 특정 데이터에 대한 잠금을 보장하기 위한 기본 키
  - type과 id 칼럼을 primary key 로 지정해서 동시에 두 사용자가 특정 타입 데이터에 대한 잠금을 구하는 것을 방지
- lockid : 각 잠금을 구분하기 위한 유니크 값
- expiration_time : 잠금 유효 시간

> 위는 MySQL용이므로 다른 DBMS를 사용한다면 해당 DBMS에 맞게 변형해서 사용하면 된다.

- ex. Order 타입의 1번 식별자를 갖는 애그리거트에 대한 잠금을 구하기
  ```sql
  insert into locks values ('Order', '1', '생성한lockid', '2016-03-28 09:10:00')
  ```
  insert 쿼리를 이용해서 locks 테이블에 데이터를 삽입하면 된다.


### 잠금 데이터 클래스 (LockData)

locks 테이블의 데이터를 담을 LockData 클래스

```java
public class LockData {
    private String type;
    private String id;
    private String lockId;
    private long expirationTime;

    public LockData(String type, String id, String lockId, long expirationTime) {
        this.type = type;
        this.id = id;
        this.lockId = lockId;
        this.expirationTime = expirationTime;
    }

    public String getType() { return type; }
    public String getId() { return id; }
    public String getLockId() { return lockId; }
    public long getExpirationTime() { return expirationTime; }

    public boolean isExpired() {
        return expirationTime < System.currentTimeMillis();
    }
}
```
- isExpired() : 현재 시간이 만료 시간보다 크면 잠금 만료 상태로 판단

### LockManager 구현

```java
package com.myshop.lock;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Timestamp;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Component
public class SpringLockManager implements LockManager {

    private int lockTimeout = 5 * 60 * 1000; // 5분
    private JdbcTemplate jdbcTemplate;

    // RowMapper : ResultSet → LockData 변환
    private RowMapper<LockData> lockDataRowMapper = (rs, rowNum) ->
            new LockData(
                    rs.getString("type"),
                    rs.getString("id"),
                    rs.getString("lockid"),
                    rs.getTimestamp("expiration_time").getTime()
            );

    /**
     * 잠금 시도
     */
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    @Override
    public LockId tryLock(String type, String id) throws LockException {
        checkAlreadyLocked(type, id);
        LockId lockId = new LockId(UUID.randomUUID().toString());
        locking(type, id, lockId);
        return lockId;
    }

    /**
     * 이미 잠금이 존재하는지 확인
     */
    private void checkAlreadyLocked(String type, String id) {
        List<LockData> locks = jdbcTemplate.query(
                "select * from locks where type = ? and id = ?",
                lockDataRowMapper, type, id
        );

        Optional<LockData> lockData = handleExpiration(locks);
        if (lockData.isPresent()) {
            throw new AlreadyLockedException();
        }
    }

    /**
     * 만료된 잠금 처리
     */
    private Optional<LockData> handleExpiration(List<LockData> locks) {
        if (locks.isEmpty()) return Optional.empty();

        LockData lockData = locks.get(0);
        if (lockData.isExpired()) {
            jdbcTemplate.update(
                    "delete from locks where type = ? and id = ?",
                    lockData.getType(), lockData.getId()
            );
            return Optional.empty();
        } else {
            return Optional.of(lockData);
        }
    }

    /**
     * 잠금 등록
     */
    private void locking(String type, String id, LockId lockId) {
        try {
            int updatedCount = jdbcTemplate.update(
                    "insert into locks values (?, ?, ?, ?)",
                    type, id, lockId.getValue(), new Timestamp(getExpirationTime())
            );
            if (updatedCount == 0) {
                throw new LockingFailException();
            }
        } catch (DuplicateKeyException e) {
            throw new LockingFailException(e);
        }
    }

    /**
     * 잠금 만료 시간 계산
     */
    private long getExpirationTime() {
        return System.currentTimeMillis() + lockTimeout;
    }

    /**
     * 잠금 검증
     */
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    @Override
    public void checkLock(LockId lockId) throws LockException {
        Optional<LockData> lockData = getLockData(lockId);
        if (!lockData.isPresent()) {
            throw new NoLockException();
        }
    }

    /**
     * lockId로 잠금 데이터 조회
     */
    private Optional<LockData> getLockData(LockId lockId) {
        List<LockData> locks = jdbcTemplate.query(
                "select * from locks where lockid = ?",
                lockDataRowMapper, lockId.getValue()
        );
        return handleExpiration(locks);
    }

    /**
     * 잠금 시간 연장
     */
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    @Override
    public void extendLockExpiration(LockId lockId, long inc) {
        Optional<LockData> lockDataOpt = getLockData(lockId);
        LockData lockData = lockDataOpt.orElseThrow(NoLockException::new);

        jdbcTemplate.update(
                "update locks set expiration_time = ? where type = ? and id = ?",
                new Timestamp(lockData.getExpirationTime() + inc),
                lockData.getType(), lockData.getId()
        );
    }

    /**
     * 잠금 해제
     */
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    @Override
    public void releaseLock(LockId lockId) throws LockException {
        jdbcTemplate.update(
                "delete from locks where lockid = ?",
                lockId.getValue()
        );
    }

    @Autowired
    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }
}
```
#### 구성요소
```java
    private int lockTimeout = 5 * 60 * 1000; // 5분
    private JdbcTemplate jdbcTemplate;

    // RowMapper : ResultSet → LockData 변환
    private RowMapper<LockData> lockDataRowMapper = (rs, rowNum) ->
            new LockData(
                    rs.getString("type"),
                    rs.getString("id"),
                    rs.getString("lockid"),
                    rs.getTimestamp("expiration_time").getTime()
            );
```
- JdbcTemplate : DB 접근 처리
- lockTimeout : 기본 잠금 시간 (예: 5분)
- RowMapper : locks 테이블 → LockData 매핑

#### tryLock() – 잠금 시도

```java
@Transactional(propagation = Propagation.REQUIRES_NEW)
@Override
public LockId tryLock(String type, String id) throws LockException {
    checkAlreadyLocked(type, id);  // 이미 잠금 여부 확인
    LockId lockId = new LockId(UUID.randomUUID().toString()); // 새로운 LockId 생성
    locking(type, id, lockId);     // 잠금 등록
    return lockId;
}
```
type과 id에 대한 잠금을 시도한다.

1. **checkAlreadyLocked()**: 해당 type과 id에 잠금이 선점됐는지 확인
   * `type + id`로 기존 잠금 조회
   * 만료된 잠금은 삭제
   * 유효한 잠금이 존재하면 `AlreadyLockedException` 발생
2.  새로운 Lockld 생성(매번 새로운 Lockld 생성(UUID 사용))
3. **locking()**: 잠금을 생성
   *  잠금을 위해 locks 테이블에 데이터를 삽입(insert)
   *  데이터 삽입 결과가 없으면(updatedCount == 0) 익셉션 발생
   * 중복 키(`DuplicateKeyException`) 발생 시 `LockingFailException` 발생
4. Lockld 리턴

#### 만료 처리 (handleExpiration)

```java
private Optional<LockData> handleExpiration(List<LockData> locks) {
    if (locks.isEmpty()) return Optional.empty();
    LockData lockData = locks.get(0);
    if (lockData.isExpired()) {
        jdbcTemplate.update(
            "delete from locks where type = ? and id = ?",
            lockData.getType(), lockData.getId());
        return Optional.empty();
    } else {
        return Optional.of(lockData);
    }
}
```

* **만료된 잠금 → 삭제 후 빈 Optional 반환**
* **유효한 잠금 → LockData를 가진 Optional을 리턴**

#### checkLock() – 잠금 검증

```java
@Transactional(propagation = Propagation.REQUIRES_NEW)
@Override
public void checkLock(LockId lockId) throws LockException {
    Optional<LockData> lockData = getLockData(lockId);
    if (!lockData.isPresent()) throw new NoLockException();
}
```

* 잠금이 유효한지 검사
  * `lockId` 기준으로 조회 → 존재하지 않거나 만료 시 예외 발생
  * getLockData (LockId lockId): lockld에 해당하는 LockData를 구한다. 
    * handleExpiration()을 이용해서 유효 시간이 지난 LockData를 처리한다.

#### extendLockExpiration() – 만료 시간 연장

```java
@Transactional(propagation = Propagation.REQUIRES_NEW)
@Override
public void extendLockExpiration(LockId lockId, long inc) {
    Optional<LockData> lockDataOpt = getLockData(lockId);
    LockData lockData = lockDataOpt.orElseThrow(NoLockException::new);

    jdbcTemplate.update(
        "update locks set expiration_time = ? where type = ? AND id = ?",
        new Timestamp(lockData.getExpirationTime() + inc),
        lockData.getType(), lockData.getId());
}
```

* lockld에 해당하는 잠금 만료 시간을 inc 만큼 늘린다.

#### releaseLock() – 잠금 해제

```java
@Transactional(propagation = Propagation.REQUIRES_NEW)
@Override
public void releaseLock(LockId lockId) throws LockException {
    jdbcTemplate.update(
        "delete from locks where lockid = ?", lockId.getValue());
}
```

* `lockId` 기준으로 잠금 해제: lockld에 해당하는 잠금 데이터를 locks 테이블에서 삭제한다.

#### 전체 흐름 요약

1. **tryLock(type, id)**
   * 기존 잠금 여부 확인 (`checkAlreadyLocked`)
   * 유효하지 않으면 새로운 잠금 등록
2. **checkLock(lockId)**
   * 현재 잠금이 존재하는지 확인
3. **extendLockExpiration(lockId, inc)**
   * 잠금 유효 시간 연장
4. **releaseLock(lockId)**
   * 잠금 해제


* **DB 기반 잠금 관리 장점**

  * 분산 환경에서 여러 애플리케이션 인스턴스가 동시에 잠금을 공유 가능
  * 트랜잭션과 함께 동작하므로 안정적

* **주의할 점**

  * 성능 부담 (잠금이 DB I/O 의존)
  * 만료 처리 로직이 중요 (handleExpiration)
