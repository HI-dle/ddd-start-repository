# 3.4 ID를 이용한 애그리거트 참조

한 객체가 다른 객체를 참조하는 것처럼 애그리거트도 다른 애그리거트를 참조합니다. 애그리거트 관리 주체는 `애그리거트 루트`이므로
애그리거트에서 다른 애그리거트를 참조한다는 것은 다른 애그리거트의 루트를 참조한다는 것과 같습니다.

애그리거트 간의 참조는 `필드를 통해 쉽게 구현`할 수 있습니다.

예를 들어 주문 애그리거트에 속해 있는 `Orderer`는 아래 처럼 주문한 회원을 참조하기 위해 회원 애그리거트 루트인 `Member`를 필드로 참조할 수 있습니다.

![3-6.png](image%2F3-6.png)

필드를 이용해서 다른 애그리거트를 직접 참조하는 것은 개발자에게 `구현의 편리함`을 제공합니다.

예를 들어, 주문 정보 조회 화면에서 회원ID를 이용해 링크를 제공해야 할 경우 다음과 같이 `Order`로부터 시작해서 회원ID를 구할 수 있습니다.

```
order.getOrderer().getMember().getId();
```

JPA는 `@ManyToOne`, `@OneToOne`과 같은 애너테이션을 이용해서 연관된 객체를 로딩하는 기능을 제공하고 있으므로, 필드를 이용해 다른 애그리거트를 쉽게 참조할
수 있습니다.

ORM 기술 덕에 `애그리거트 루트에 대한 참조`를 쉽게 구현할 수 있고, 필드(또는 `get` 메서드)를 이용한 애그리거트 참조를 사용하면 다른 애그리거트의 데이터를 쉽게 조회할
수 있습니다.

하지만, 필드를 이용한 애그리거트 참조는 다음 문제를 야기할 수 있습니다.

- 편한 탐색 오용
- 성능에 대한 고민
- 확장 어려움

첫번째로, 애그리거트를 직접 참조할 때 발생할 수 있는 가장 큰 문제는 `편리함을 오용`할 수 있다는 것입니다.

한 애그리거트 내부에서 다른 애그리거트 객체에 접근할 수 있으면 다른 애그리거트의 상태를 쉽게 변경할 수 있게 됩니다. 트랜잭션 범위에서 언급했던
것처럼 `한 애그리거트가 관리하는 범위는 자기 자신`으로 한정해야 합니다.
> 애그리거트 내부에서 다른 애그리거트 객체에 접근할 수 있으면 `구현의 편리함` 때문에 `다른 애그리거트를 수정하고자 하는 유혹`에 빠지기 쉽다!

아래 코드는 유혹에 빠져버린 예시입니다.

```java
public class Order {

  private Orderer orderer;

  public void changeShippingInfo(ShippingInfo newShippingInfo,
      boolean useNewShippingAddrAsMemberAddr) {

    // ...
    if (useNewShippingAddrAsMemberAddr) {
      // 아래 처럼 Order 애그리거트에서 Member 애그리거트의 상태를 변경하는 유혹에 빠져버리게 된다!
      orderer.getMemeber().changeAddress(newShippingInfo.getAddress());
    }
  }
}
```

위와 같이 한 애그리거트에서 다른 애그리거트의 상태를 변경하는 것은 `애그리거트 간의 의존 결합도`를 높여서 결과적으로 애그리거트의 `변경을 어렵게` 만듭니다.

---
두 번째 문제는 애그리거트를 직접 참조하면 `성능과 관련된 여러 가지 고민을 해야 한다`는 것입니다.

JPA를 사용하면 참조한 객체를 `지연(lazy) 로딩`과 `즉시(eager) 로딩`의 두 가지 방식으로 로딩할 수 있습니다. 두 로딩 방식 중 무엇을 선택할지는 애그리거트의 어떤
기능을 사용하느냐에 따라 달라집니다.

- 만약, 단순히 연관된 객체의 데이터를 함께 화면에 보여줘야 하면 `즉시 로딩`이 조회에 유리
- 하지만, 애그리거트의 상태를 변경하는 기능을 실행하는 경우에는 불필요한 로딩은 필요가 없으므로 `지연 로딩`이 유리

이와 같이 다양한 경우의 수를 고려해서 연관 매핑과 `JPQL/Criteria` 쿼리의 로딩 전략을 결정해야 합니다.

---
세 번째 문제는 확장입니다. 초기에는 단일 서버에 단일 DBMS로 서비스를 제공하는 것이 가능합니다. 하지만 문제는 사용자가 몰리기 시작하면서 발생합니다.

사용자와 트래픽이 증가하면 부하를 분산하기 위해 `하위 도메인별로 시스템을 분리`하기 시작합니다. 이 과정에서 하위 도메인마다 서로 다른 DBMS를 사용할 때도 있습니다. 심지어는
하위 도메인마다 다른 종류의 데이터 저장소를 사용하기도 합니다.

이것은 더 이상 **다른 애그리거트 루트를 참조하기 위해 JPA와 같은 단일 기술을 사용할 수 없음을 의미**합니다.

위의 세 가지 문제를 완화할 때 사용할 수 있는 것이 **ID를 이용해서 다른 애그리거트를 참조하는 것**입니다.

![3-7.png](image%2F3-7.png)

ID 참조를 사용하면 한 애그리거트에 속한 객체들만 참조로 연결됩니다. 이는 애그리거트의 `경계를 명확히`하고 애그리거트 간 `물리적인 연결을 제거`하기 때문에 모델의 복잡도를
낮추고, 애그리거트 간의 의존을 제거하므로 응집도를 높여줍니다.

또한 애그리거트를 직접 참조하지 않으므로 애그리거트 간 참조를 지연 로딩으로 할지 즉시 로딩으로 할지 고민하지 않아도 됩니다.

아래 예시처럼 참조하는 애그리거트가 필요하면 응용 서비스(application service)에서 ID를 이용해서 로딩하면 됩니다.
```java
public class ChangeOrderService {
  
  @Transactional
  public void changeShippingInfo(OrderId id, ShippingInfo newShippingInfo) {
    // ...
    Order order = orderRepository.findById(id).orElseThrow(() -> new OrderNotFoundException());
    
    // memberId를 이용해서 로딩
    Member member = memberRepository.findById(order.getOrderer().getMemberId());
  }
}
```

응용 서비스에서 필요한 애그리거트를 로딩하므로 `애그리거트 수준에서 지연 로딩을 하는 것과 동일한 결과`를 만듭니다.

`ID를 이용한 참조 방식`을 사용하면 복잡도를 낮춤과 동시에 한 애그리거트에서 다른 애그리거트를 수정하는 문제를 근원적으로 방지할 수 있습니다.
외부 애그리거트를 직접 참조하지 않기 때문에 불가능해지기 때문입니다.

또한 아래 그림처럼 확장에도 용이하게 됩니다.

![3-8.png](image%2F3-8.png)

- 애그리거트 별로 다른 구현 기술(JPA 맑고도)을 사용하는 것이 가능해집니다.
- 리포지토리마다 다른 저장소를 사용할 수 있기 때문에 확장에 용이합니다.
- 각 도메인을 별도 프로세스로 서비스하도록 구현할 수도 있습니다.