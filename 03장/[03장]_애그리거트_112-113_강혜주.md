# 3.3 리포지터리와 애그리거트

애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 **객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다.**
Order 와 OrderLine을 물리적으로 각각 별도의 DB 테이블에 저장한다고 해서, 각각의 리포지터리를 만드는 것이 아니다.

Order 가 애그리거트 루트이고, OrderLine은 애그리거트의 구성요소 이므로 **Order 를 위한 리포지터리만 존재한다.**
새로운 애그리거트를 만들면 저장소에 애그리거트를 영속화(저장) 하고,
애그리거트를 사용하려면 저장소에서 애그리거트를 읽어야 하므로, 리포지터리는 보통 다음의 두 메서드를 기본적으로 제공한다.

- save : 애그리거트 저장
- findById: ID로 애그리거트를 구함

이 두 메서드 외에도 필요한 조건으로 다양한 메서드를 추가할 수 있다(검색, 삭제 등)

어떤 기술을 이용해서 리포지터리를 구현하느냐에 따라서 애그리거트의 구현도 영향을 받는다.
JPA를 사용하는 경우, 데이터베이스 관계형 모델에 객체 도메인 모델(`@Entity`)을 맞춰야 할 때도 있다.
특히 레거시 DB를 사용하거나, 팀 내 DB 설계 표준을 따라야 한다면, DB 테이블 구조에 맞게 모델을 변경해야 한다. 이 경우 밸류 타입인 도메인 모델을 `@Component`가 아닌 `@Entity`로 사용해야 할 수도 있다.
> 기존에 짜여진 DB구조를 따르기 위해 이상적인 도메인 설계를 DB에 맞춘 설계로 타협해야 하는 경우를 말하는 것 같습니다.

**애그리거트는 개념적으로 하나**이므로, 리포지터리는 애그리거트 전체를 저장소에 영속화 해야한다.

예를 들어 Order 애그리거트와 관련된 테이블이 세 개 라면, Order 애그리거트를 저장할 때 애그리거트 루트와 매핑되는 테이블뿐만 아니라 애그리거트에 속한 모든 구성요소에 매핑된 테이블에 데이터를 저장해야한다.

```java
// 리포지터리에 애그리거트를 저장하면 애그리거트 전체(모든 구성요소 포함)를 영속화해야 한다.
orderRepository.save(order);
```

동일하게 애그리거트를 구하는 리포지터리 메서드는 완전한 애그리거트를 제공해야 한다.

```java
// 리포지터리는 Orderer, OrderLine 등 모든 구성요소를 포함한 완전한 order를 제공하야 한다.
Order order = orderRepository.findById(orderId);

// order가 온전한 애그리거트가 아니면
// 기능 실행 도중 NullPointerException 과 같은 문제가 발생한다.
order.cancel();
```

리포지터리가 완전한 애그리거트를 제공하지 않으면, 필드나 값이 올바르지 않아 애그리거트의 기능을 실행하는 도중에 NPE와 같은 문제가 발생할 수 있다.

애그리거트를 영속화할 저장소로 무엇을 사용하든지 간에 (*마리아DB, 오라클 , 몽고DB 등*) 애그리거트의 상태가 변경되면 모든 변경을 원자적으로 저장소에 반영해야 한다.
애그리거트에서 두 개의 객체를 변경했는데 저장소에는 한 객체에 대한 변경만 반영되면 데이터 일관성이 깨지므로 문제가 된다.

RDBMS를 이용해서 리포지터리를 구현하면 **트랜잭션**을 이용해서 애그리거트의 변경이 원자적으로 저장소에 반영되는 것을 보장할 수 있다.
몽고DB를 사용하면 한 개 애그리거트를 한 개 문서에 저장함으로써 한 애그리거트의 변경을 손실없이 저장소에 반영할 수 있다.
> MongoDB는 문서에 중첩 구조로 애그리거트를 표현할 수 있고, 문서 단위로 원자적 쓰기를 보장할 수 있는 것 같습니다.