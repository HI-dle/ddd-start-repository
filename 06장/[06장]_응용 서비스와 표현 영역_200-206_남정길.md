# 6.1 표현 영역과 응용 영역

응용 영역과 표현 영역은 **사용자와 도메인 영역을 연결해 주는 매개체** 역할을 한다.

## 1. 표현 영역 (Presentation Layer)

- 사용자의 요청을 해석
- URL, 파라미터, 쿠키, 헤더 등을 통해 사용자가 원하는 기능을 판별하고 그에 맞는 **응용 서비스(Application Service)** 실행

## 2. 응용 영역 (Application Layer)

- 실제 사용자가 원하는 기능을 제공
- 도메인 객체를 사용하여 요청된 기능을 실행
- **도메인 로직을 포함하지 않음**

---

### 표현 ↔ 응용 영역 간 데이터 변환

- 응용 서비스의 메서드가 요구하는 파라미터 형식과  
  표현 영역에서 전달받은 데이터의 형식은 다를 수 있다.
- 따라서 표현 영역에서는 **요청 데이터를 변환한 후 응용 서비스 메서드를 호출**해야 한다.

### 응답 처리

- 응용 서비스를 실행한 후, 표현 영역은 **사용자 요청에 맞게 HTML, JSON 등으로 응답**을 생성한다.
- 사용자와의 상호작용은 표현 영역이 담당하므로,  
  응용 서비스는 사용자가 **웹 브라우저, REST API, TCP 소켓 중 무엇을 사용하는지 알 필요가 없다.**

---
# 6.2 응용 서비스의 역할
- 응용서비스는 사용자의 요청을 처리하기 위해 도메인 객체를 가져와 사용한다.
- 도메인 영역과 표현영역을 연결해 주는 창구 역할
- 트랜잭션 처리 담당 
>만약 한번에 다수회원을 차단상태로 변경하는 서비스가 있을때 트랜잭션 범위에서 실행되지 않는다면 실행중 상태를 변경했을때 DB에 반영하는 도중 문제가 발생하면  일부 Member만 차단상태가 되어 데이터 일관성이 깨지게 된다.

### 응용서비스의 형태

1. 레포지터리에서 애그리거트를 구한다.
2. 애그리거트의 도메인 기능 실행
3. 결과 리턴
- 생성시
1. 데이터중복, 유효성 검사
2. 애그리거트 생성
3. 리포지터리 저장
4. 결과 리턴

## 6.2.1 도메인 로직 넣지 않기

- **도메인 로직은 반드시 도메인 영역에 위치해야 하며, 응용 서비스에 작성해서는 안 된다.**

### 예시코드

```java
public void changePassword(String memberId, String oldPassword, String newPassword) {
    Member member = memberRepository.findById(memberId);
    checkMemberExists(member);
    member.changePassword(oldPassword, newPassword);
}
```

```java
public class Member {
  
    public void changePassword(String oldPassword, String newPassword) {
        if (!matchPassword(oldPassword)) throw new BadPasswordException();
        setPassword(newPassword);
    }

    public boolean matchPassword(String password) {
        return passwordEncoder.matches(password);
    }

    public void setPassword(String newPassword) {
        if (isEmpty(newPassword)) throw new IllegalArgumentException("no new password");
        this.password = newPassword;
    }
}
```

```java
public class ChangePasswordService{

  public void changePassword(String memberId, String oldPassword, String newPassword) {
    Member member = memberRepository.findById(memberId);
    checkMemberExists(member);
    //이 로직은 도메인의 핵심 로직이기 때문에 응용서비스에서 이 로직을 구현하면 안된다.
     if (!passwordEncroder.matches(oldPassword,member.getPassword())) {
      throw new BadPasswordException();
     }

    member.setPassword(newPassword);
  }
}

```
- 비밀번호 일치 여부 확인은 도메인의 핵심 로직 → 도메인 객체가 책임져야 한다.

### 도메인 로직 분산 시 발생하는 문제
1. 응집도 저하
 - 도메인 데이터와 그 데이터를 조작하는 도메인 로직이 한곳에 있지 않고 서로 다른 영역에 있다는 것은 도메인을 파악하기 위해 여러 영역을 분석해야 한다는 것을 의미
2. 중복 코드 증가
- 여러 응용 서비스가 동일한 도메인 로직을 각각 구현하는 문제 발생

- 예를 들어 비정상적인 계정 정지를 막기 위해 암호를 확인한다고 했을때 이 경우 아래와 같이 암호 확인 로직의 중복 발생

```java
public class DeactivationService {
  public void deactivate(String memberId, String pwd) {
    Member member = memberRepository.findById(memberId);
    checkMemberExists(member);
    if (!passwordEncoder.matches(pwd, member.getPassword())) {
        throw new BadPasswordException();
    }
    member.deactivate();
  }
}
```
이 중복 코드는 Member 도메인 객체에 위임했으면 방지 가능

 소프트 웨어가 가져야할 중요한 요소중 하나는 변경 용이성인데 변경이 어렵다는 것은 그만큼  소프트웨어의 가치가 떨어진다는 것을 의미
 따라서 도메인로직을 도메인 영역에 모아 코드 중복을 줄이고 응집도를 높여야 한다.

