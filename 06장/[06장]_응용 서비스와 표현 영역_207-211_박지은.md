# 6.3 응용 서비스의 구현

응용 서비스는 표현 영역과 도메인 영역을 연결하는 매개체 역할을 하는데 이는 디자인 패턴의 `facade`와 같은 역할을 한다. 

응용 서비스 자체는 복잡한 로직을 수행하지 않아 응용 서비스의 구현은 어렵지 않다. 

이 절에서는 응용 서비스를 구현할 때 고려할 사항과 트랜잭션 같은 구현 기술의 연동에 대해 살펴본다.

## 6.3.1 응용 서비스의 크기

응용 서비스의 크기를 고려해야 한다. 

### 예시. 회원 도메인 응용 서비스 기능
> - 회원 가입하기
> - 회원 탈퇴하기
> - 회원 암호 변경하기
> - 비밀번호 초기화하기

와 같은 기능을 구현하기 위해 도메인 모델을 사용하게 된다.

- 이 경우 응용 서비스는 보통 다음의 두 가지 방법 중 한 가지 방식으로 구현한다. 
  1. 한 응용 서비스 클래스에 회원 도메인의 모든 기능 구현하기
  2. 구분되는 기능별로 응용 서비스 클래스를 따로 구현하기

#### 1. 한 응용 서비스 클래스에 회원 도메인의 모든 기능 구현하기

회원과 관련된 기능을 한 클래스에서 모두 구현하면 다음과 같은 모습을 갖는다.

- 각 메서드를 구현하는 데 필요한 리포지터리나 도메인 서비스는 `필드`로 추가한다.

```java
public class MemberService {

  // 각 기능을 구현하는 데 필요한 리포지터리, 도메인 서비스 필드 추가
  private MemberRepository memberRepository;

  public void join(MemberJoinRequest joinRequest) { ...}

  public void changePassword(String memberId, String curPw, String newPw) { ...}

  public void initializePassword(String memberId) { ...}

  public void leave(String memberId, String curPw) { ...}
}
```
- 장점: 각 기능에서 동일 로직에 대한 코드 중복을 제거 가능

  > ex. changePassword(), initializePassword(), leave(): 회원이 존재하지 않으면 NoMemberException 필요한 상황
  >    - 중복된 로직을 구현한 private 메서드를 구현하고 이를 호출하는 방법으로 중복 로직 제거 가능
  >  
  >    ```java
  >    public class MemberService {
  >  
  >      private MemberRepository memberRepository;
  >      private Notifier notifier;
  >  
  >      public void changePassword(String memberId, String currentPw, String newPw) {
  >        Member member = findExistingMember(memberId);
  >        member.changePassword(currentPw, newPw);
  >      }
  >  
  >      public void initializePassword(String memberId) {
  >        Member member = findExistingMember(memberId);
  >        String newPassword = member.initializePassword();
  >        notifier.notifyNewPassword(member,newPassword);
  >      }
  >  
  >      public void leave(String memberId, String curPw) { ...
  >        Member member = findExistingMember(memberId);
  >        member.leave();
  >      }
  >  
  >      // 각 기능의 동일 로직에 대한 구현 코드 중복을 쉽게 제거
  >      private Member findExistingMember(String memberId) {
  >        Member member = memberRepository.findById(memberId);
  >        if (member == nul1)
  >          throw new NoMemberException(memberId);
  >        return member;
  >      }
  >    }
  >    ```

- 단점
  1. 한 서비스 클래스의 크기(코드 줄 수)가 커진다 
  2. 코드 크기가 커지면 연관성이 적은 코드가 한 클래스에 함께 위치할 가능성이 높아진다.
     - ➡️ 관련 없는 코드가 뒤섞여 코드를 이해하는 데 방해
         - ex. 암호 초기화 기능: `initializePassword()`
           - 암호 초기화 후에 신규 암호를 사용자에게 통지하기 위해 Notifier를 사용
             - `Notifier`는 암호 변경 기능(`changePassword()`)에서는 필요하지 않은 기능
               - 하지만 Notifier가 필드로 존재하기 때문에 이 Notifier가 어떤 기능 때문에 필요한지 확인하려면 각 기능을 구현한 코드 확인 필요
     - 한 클래스에 코드가 모이기 시작하면 분리하는 것이 좋은 상황임에도 기존에 존재하는 클래스에 억지로 끼워 넣게 된다. 
       - ➡️ 코드를 점점 얽히게 만들고 코드 품질을 낮춤

#### 2. 구분되는 기능별로 응용 서비스 클래스를 따로 구현하기
- 구분되는 기능별로 서비스 클래스를 구현하는 방식은 한 응용 서비스 클래스에서 한 개 내지 2~3개의 기능을 구현한다. 
    > ex. 암호 변경 기능만을 위한 응용 서비스 클래스 별도 구현
    >
    > ```java
    > public class ChangePasswordService {
    >   private MemberRepository memberRepository;
    >   public void changePassword(String memberId, String curPw, String newPw) {
    >     Member member = memberRepository.findById(memberId);
    >     if (member == null)
    >       throw new NoMemberException(memberId);
    >     member.changePassword(curPw, newPw);
    >   }
    > }
    > ```
  - 이 방식을 사용하면 클래스 개수는 많아지지만 한 클래스에 관련 기능을 모두 구현하는 것과 비교해서 코드 품질을 일정 수준으로 유지하는 데 도움이 된다. 
  - 또한 각 클래스별로 필요한 의존 객체만 포함하므로 다른 기능을 구현한 코드에 영향을 받지 않는다. 

#### 중복 기능 코드 분리하기
- 각 기능마다 동일한 로직을 구현할 경우 여러 클래스에 중복해서 동일한 코드를 구현할 가능성이 있다. 
  > - 이는 별도 클래스에 로직을 구현해서 코드가 중복되는 것을 방지할 수 있다.
  >  
  > ```java
  > // 각 응용 서비스에서 공통되는 로직을 별도 클래스로 구현
  > public final class MemberServiceHelper {
  >   public static Member findExistingMember(MemberRepository repo, String memberId) {
  >     Member member = memberRepository.findById(memberId);
  >     if (member == nul1)
  >       throw new NoMemberException (memberId);
  >     return member;
  >   }
  > }
  > ```
  > ```java
  > // 공통 로직을 제공하는 메서드를 응용 서비스에서 사용
  > import static com.myshop.member.application.MemberServiceHelper.*;
  > public class ChangePasswordService {
  > 
  >   private MemberRepository memberRepository;
  > 
  >   public void changePassword(String memberId, String curPw, String newPw) {
  >     Member member = findExistingMember(memberRepository, memberId);
  >     member.changePassword(curPw, newPw);
  >   }
  > }
  > ```

책에서는 한 클래스가 여러 역할을 갖는 것보다 각 클래스마다 구분되는 역할을 갖는 것을 선호한다. 

한 도메인과 관련된 기능을 하나의 응용 서비스 클래스에서 모두 구현하는 방식보다 

구분되는 기능을 별도의 서비스 클래스로 구현하는 방식을 사용한다.

## 6.3.2 응용 서비스의 인터페이스와 클래스

응용 서비스를 구현할 때 인터페이스가 필요한가? 

다음과 같이 인터페이스를 만들고 이를 상속한 클래스를 만드는 것이 필요할까?

```java
public interface ChangePasswordService {
  public void changePassword(String memberId, String curPw, String newPw);
}
```
```java
public class ChangePasswordServiceImpl implements ChangePasswordService {
  ...구현
}
```

### 응용 서비스(Application Service)에 인터페이스가 필요한 경우

1. 구현 클래스가 여러 개인 경우
   - 구현 클래스가 다수 존재하거나 런타임에 구현 객체를 교체해야 할 때 인터페이스를 유용하게 사용할 수 있다. 
     - 다만, 응용 서비스는 런타임에 교체하는 경우가 거의 없고 한 응용 서비스의 구현 클래스가 두 개인 경우도 드물다.
       - 이런 이유로 인터페이스와 클래스를 따로 구현하면 소스 파일만 많아지고 구현 클래스에 대한 간접 참조가 증가해서 전체 구조가 복잡해진다. 
       - 따라서 인터페이스가 명확하게 필요하기 전까지는 응용 서비스에 대한 인터페이스를 작성하는 것이 좋은 선택이라고 볼 수는 없다.
2. 테스트 주도 개발(Test Driven Development,TDD)
   - 표현 영역(예: Spring MVC Controller)부터 개발할 경우: TDD
     - 아직 응용 서비스 구현 클래스가 없음
     - 이때 응용 서비스 인터페이스를 먼저 정의하게 됨 
       - ex. 스프링 MVC의 컨트롤러 TDD로 개발
         - 컨트롤러에서 사용할 응용 서비스 클래스의 구현은 존재하지 않음
         - 응용 서비스의 인터페이스를 이용해서 컨트롤러의 구현을 완성해 나갈 수 있다.
   - 응용 영역의 개발을 먼저 시작한 경우: 표현 영역의 단위 테스트
     - 표현 영역의 단위 테스트를 위해 가짜 객체(Mock)가 필요
       - 표현 영역의 응용 서비스 클래스의 가짜 객체를 위해 인터페이스를 추가 가능 
     - But, 인터페이스 없이도 Mockito 등으로 클래스 기반 Mock 생성 가능 ➡️ 따라서 이런 경우에도 인터페이스가 필수는 아님