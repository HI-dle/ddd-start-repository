# 응용 서비스와 표현 영역

---

## 6.5 값 검증

 - 값 검증은 표현 영역과 응용 서비스 두 곳에서 모두 수행할 수 있다. 원칙적으로 모든 값에 대한 검증은 응용 서비스에서 처리한다.

```java
public class JoinService {
	
    @Transactional
    public void join(JoinRequest joinReq){
    	// 값의 형식 검사
        checkEmpty(joinReq.getId(), "id");
        checkEmpty(joinReq.getName(), "name");
        
        if (joinReq.getPassword().equarls(joinReq.getConfirmPassword()))
        	throw new InvalidPropertyException("confirmPassword");
    }
    
    private void checkEmpty(String value, String propertyName){
    	if (value == null || value.isEmpty())
        	throw new EmptyPropertyException(propertyName);
    }
}

```
 - 위는 응용 서비스애서 파라미터로 전달 받은 값이 올바른지 검사하는 것이다.
 - 표현 영역은 잘못된 값이 존재하면 이를 사용자에게 알려주고 값을 다시 입력받아야 한다. 스프링 MVC는 입력한 값이 잘못된 경우 에러 메시지를 보여주기 위한 용도로 Errors나 BindingResult를 사용하는데 컨트롤러에서 위와 같은 응용 서비스를 사용하면 폼에 에러 메시지를 보여주기 위해 다음과 같은 코드를 작성해야 한다.

```java
@Controller
public class Controller {
  
  ...
  
  @PostMapping("/member/join")
  public String join(JoinRequest joinRequest, Errors errors) {
    try {
      joinservice.join(joinRequest);
      return successView;
    } catch (EmptyPropertyException ex) {
      //표현 영역은 잘못 입력한 값이 존재하면 이를 사용자에게 알려주고 폼을 다시 입력할 수 있도록 하기 위한 관련 기능을 사용
      errors.rejectvalue(ex.getPropertyName(), "empty");
      return formView;
    } catch (InvalidPropertyException ex) {
      errors.rejectvalue(ex.getPropertyName(), "invalid");
      return formView;
    }
    ...
  } 
}
```

 - 응용 서비스에서 각 값이 유효한지 확인할 목적으로 익셉션을 사용할 때 문제점은 사용자에게 좋은 경험이 아니며, 사용자는 폼에 값을 입력하고 전송했는데 입력한 값이 잘못되어 다시 폼에 입력해야 할 때 한 개 항목이 아닌 입력한 모든 항목에 대해 잘못된 값이 존재하는지 알고 싶을 것이다.
 - 응용 서비스에서 값을 검사하는 시점에 첫 번째 값이 올바르지 않아 익셈션을 발생시키면 나머지 항목에 대해서는 값을 검사하지 않게 된다. 이러면 사용자는 첫 번째 값에 대한 에러 메시지만 보게 되고 나머지 항목에 대해서는 값이 올바른지 알 수 없게 된다. 이는 사용자에게 같은 폼에 값을 여러 번 입력하게 만든다.


 - 이 불편을 해소하기 위해 응용 서비스에서 에러 코드를 모아 하나의 익셉션으로 발생 시키는 방법도 있다.

```java

import java.util.ArrayList;

@Transactional
public Orderno placeOrder(OrderRequest orderRequest) {
  List<ValidationError> errors = new ArrayList<>();
  if (orderRequest == null) {
    errors.add(ValidationError.of("empty"));
  } else {
    if (orderRequest.getOrdererMemberId() == null)
      errors.add(ValidationError.of("ordererMemberId", "empty"));
    if (orderRequest.getOrderProducts() == null)
      errors.add(ValidationError.of("orderProducts", "empty"));
    
    ...
  }
  // 응용 서비스가 입력 오류를 하나의 익셉션으로 모아서 발생
  if (!errors.isEmpty()) throw new ValidationErrorException(errors);
}
```

 - 표현 영역에서는 응용 서비스가 ValidationErrorException을 발생 시키면 익셉션에서 에러 목록을 가져와 표현 영역에서 사용할 형태로 변환 처리한다.

```java

...
  catch (ValidationErrorException e) {
    //응용 서비스가 발생시킨 검증 에러 목록을 뷰에서 사용할 형태로 변환
    e.getErrors().forEach(err -> {
      if (err,hasName()) {
        bindingResult.rejectValue(err.getName(), err.getCode());
    } else {
        bindingResult.reject(err.getCode());
    }
    });
    ...
    }
```

 - 에러 이외에도 표현 영역에서 필수 값을 검증하는 방법도 있다.

 - 스프링 프레임 워크는 값 검증을 위한 Validator 인터페이스를 별도로 제공하므로 인터페이스를 구현한 검증기를 따로 구현할 수 있다.

```java

  @PostMapping("/member/join")
  public String join(JoinRequest joinRequest, Errors errors) {
    new joinRequestValidator().validate(joinRequest, errors);
    ...
  } 

```

 - 이렇게 표현 영역에서 필수 값과 값의 형식을 검사하면 실질적으로 응용 서비스는 ID 중목 여부와 같은 논리적 오류만 검사하면 된다.
 - 표현 영역과 응용 서비스는 ID 중복 여부와 같은 논리적 오류만 검사하면 된다.
 - 표현 영역과 응용 서비스가 값 검사를 나눠서 수행하는 것이다. 응용 서비스를 사용하는 표현 영역 코드가 한 곳이면 구현의 편리함을 위해 다믕과 같이 역할을 나누어 검증을 수행할 수 있다.
   - 표현 영역 : 필수 값, 값의 형식, 범위 등을 검증한다.
   - 응용 서비스 : 데이터의 존재 유무와 같은 논리적 오류를 검증한다.
 - 응용 서비스에서 엄격히 값을 검증하는 것은 의견이 갈릴 수 있다. 필자는 예전에는 표현 영역에서 필수 값 검증을 하고 응용에서는 논리적 검증을 하는 방식을 괜찮다고 생각하기도 했다.
 - 지금은 응용 서비스에서 가능한 필수 값과 논리적 검증을 모두 하는 것을 선호한다고 한다.
 - 응용 서비스에서 필요한 값 검증을 모두 처리하면 프레임워크가 제공하는 검증을 사용할 때보다 작성할 코드가 늘어나는 불편함이 있지만 반대로 응용 서비스의 환성도가 높아지는 이점이 있다.

