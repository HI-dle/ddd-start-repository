# 6.3 응용 서비스의 구현
## 6.3.3 메서드 파라미터와 값 리턴

응용 서비스가 제공하는 메서드는 도메인을 이용해서 사용자가 요구한 기능을 실행하는 데 필요한 값을 `파라미터로 전달받아야 합니다.`

```java
public class ChangePasswordService {
  // 암호 변경 기능에 필요한 파라미터: 회원 id, 현재 암호, 변경할 암호
  public void changePassword(String memberId, String curPw, String newPw) {
    // ...
  }
}
```

위 코드처럼 각 값을 개별 파라미터로 전달받을 수도 있지만, 별도 데이터 클래스를 만들어 전달받을 수도 있습니다.
```java
public class ChangePasswordRequest {
  private String memberId;
  private String currentPassword;
  private String newPassword;
  
  // getter 등
}
```

응용 서비스는 파라미터로 `전달받은 데이터를 사용해서 필요한 기능을 구현`하면 됩니다.
```java
public class ChangePasswordService {
  // 암호 변경 기능에 필요한 파라미터: 회원 id, 현재 암호, 변경할 암호
  public void changePassword(ChangePasswordRequest req) {
    Member member = findExistingMember(req.getMemberId());
    member.changePassword(req.getCurrentPassword(), req.getNewPassword());
  }
}
```

스프링 MVC와 같은 웹 프레임워크는 웹 요청 파라미터를 자바 객체로 변환하는 기능을 제공하므로 응용 서비스에 데이터로 전달한 요청 파라미터가 두 개 이상 존재하면,
별도 클래스를 사용하는 것이 편리합니다.
```java
@Controller
@RequestMapping("/member/changePassword")
public class MemberPasswordController {
  
  // 클래스를 이용해서 응용 서비스에 데이터를 전달하면
  // 프레임워크가 제공하는 기능을 활용하기에 좋다.
  @PostMapping()
  public String submit(ChangePasswordRequest changePwdReq) {
    Authentication auth = SecurityContext.getAuthentication();
    changePwdReq.setMemberId(auth.getId());
    try {
      changePasswordService.changePassword(changePwdReq);
    } catch (Exception e) {
      // 익셉션 처리
    }
  }
}
```

응용 서비스의 결과를 표현 영역에서 사용해야 하면, 응용 서비스 메서드의 결과로 필요한 데이터를 리턴합니다.

대표적인 예가 `식별자`인데, 온라인 쇼핑몰은 보통 주문 후 주문 상세 내역을 볼 수 있는 링크를 바로 보여주게 되는데, 이 링크를 제공하기 위해서는 방금 요청한 주문 번호를 알아야합니다.

따라서 이 요구를 충족하기 위해서 응용 서비스는 주문번호를 결과로 리턴해야합니다.
```java
public class OrderService {
  
  @Transactional
  public OrderNo placeOrder(OrderRequest orderRequest) {
    OrderNo orderNo = orderRepository.nextId();
    Order order = createOrder(orderNo, orderRequest);
    orderRepository.save(order);
    
    return orderNo; // 표현 영역에서 필요한 값 리턴
  }
}

// ---
@Controller
public class OrderController {
  
  @PostMapping("/order/place")
  public String order(OrderRequest orderReq, ModelMap model) {
    OrderNo orderNo = orderService.placeOrder(orderReq);
    
    // 응용 서비스의 리턴 값 사용
    modelMap.setAttribute("orderNo", orderNo.toString());
    
    return "order/success";
  }
}
```

표현 영역에서는 위 처럼 응용 서비스가 리턴한 결과를 통해 사용자에게 보여줄 응답 화면을 생성하면 됩니다.

위 처럼 `orderNo`와 같은 식별자를 응답해주는 것이 아닌 `Order`처럼 애그리거트 객체를 그대로 리턴할 수도 있을 것입니다.

이렇게 되면 코딩은 편할 수 있겠지만, `도메인의 로직 실행`을 응용 서비스와 표현 영역 두 곳에서 모두 할 수 있게 됩니다. 이것은 응집도를 낮추는 원인이 됩니다.

물론, 컨트롤러나 뷰 코드에서 애그리거트가 제공하는 기능을 실행하지 말자! 라는 규칙을 정할 수 있겠지만, 그보다는 응용 서비스는 표현 영역에서 필요한 데이터만 리턴하는 것이 응집도를 높이는 확실한 방법입니다.

---
## 6.3.4 표현 영역에 의존하지 않기
응용 서비스의 파라미터 타입을 결정할 때 주의할 점은 표현 영역과 관련된 타입을 사용하면 안 된다는 점입니다.

> e.g) 표현 영역에 해당하는 `HttpServletRequest`를 응용 서비스에 파라미터로 전달

이는 응용 서비스가 표현 영역에 대한 의존이 발생한다는 것이고, 다음과 같은 문제가 발생할 수 있습니다.
- 응용 서비스만 단독으로 테스트하기 어려워진다.
- 표현 영역의 구현이 변경되면 응용 서비스의 구현도 함께 변경해야한다.
- 응용 서비스가 표현 영역의 역할까지 대신하는 상황이 벌어질 수 있다.(가장 심각한 문제)

세 번째 문제점에 대한 예시로, 응용 서비스에 파라미터로 `HttpServletRequest`를 전달했고, 해당 request 정보로 `HttpSession`을 생성 후, 세션에 인증과 관련된 정보를 담는다고 해보겠습니다.
```java
public class AuthenticationService {
  public void authenticate(HttpServletRequest request) {
    String id = requset.getParameter("id");
    String password = requset.getParameter("password");
    if (check(id, password)) {
      // 응용 서비스에서 표현 영역의 상태 처리
      HttpSession session = request.getSession();
      session.setAttribute("auth", new Authentication(id));
    }
  }
  // HttpSession이나 쿠키는 표현 영역의 상태에 해당.
  // 이 상태를 응용 서비스에서 변경해버림
  // -> 표현 영역의 코드만으로 표현 영역의 상태가 어떻게 변경되는지 추적하기 어려워짐.
  // -> 표현 영역의 응집도가 깨진다. -> 유지 보수 비용 증가!
}
```

이러한 문제가 발생하지 않도록 하려면 철저하게 `응용 서비스가 표현 영역의 기술을 사용하지 않도록`해야 합니다. 이를 지키기 위한 가장 쉬운 방법은 서비스 메서드의 파라미터와 리턴 타입으로 표현 영역의 구현 기술을 사용하지 않는 것입니다.

## 6.3.5 트랜잭션 처리
회원가입에 성공했다고 하면서 실제로 회원 정보를 DB에 저장하지 않으면 고객은 로그인을 할 수가 없습니다.

이는 트랜잭션과 관련된 문제로, `트랜잭션을 관리`하는 것은 응용 서비스의 중요한 역할입니다.

스프링과 같은 프레임워크가 제공하는 트랜잭션 관리 기능을 이용하면 쉽게 트랜잭션을 처리할 수 있습니다.

```java
public class ChangePasswordService {
  
  @Transactional
  public void changePassword(ChangePasswordRequest req) {
    Member member = findExistingMember(req.getMemberId());
    member.changePassword(req.getCurrentPassword(), req.getNewPassword());
  }
}
```

프레임워크가 제공하는 트랜잭션 기능을 적극 사용하는 것이 좋습니다. 간단한 설정만으로 트랜잭션을 시작하여 커밋하고, 익셉션이 발생하면 롤백할 수 있습니다.

스프링은 `@Transactional`이 적용된 메서드가 `RuntimeException`을 발생시키면 트랜잭션을 롤백하고 그렇지 않으면 커밋하므로 규칙을 준수하여 코드를 작성하면 트랜잭션 처리를 간결하게 유지할 수 있습니다.
