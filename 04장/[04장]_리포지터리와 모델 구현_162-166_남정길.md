
# 4.4 JPA 애그리거트 로딩 전략

## 애그리거트(Aggregate)의 완전성

- JPA 매핑 시, **애그리거트는 하나의 완전한 객체 그래프**로 간주되어야 한다.
- 예:
  ```java
  Product product = productRepository.findById(id);
  ```
  위 코드처럼 루트 엔티티(Product)를 조회할 때, **루트에 속한 객체가 완전한 상태**여야 한다는 의미.
> 조회 시점에서 애그리거트를 완전한 상태가 되도록 하려면
애그리거트 루트에서 연관 매핑의 조회 방식을 즉시로딩으로 설정
---

## 즉시 로딩(EAGER Fetching)

### 즉시로딩 설정 예시
```java
@Entity
@OneToMany(cascade = {CascadeType.PERSIST, CascadeType.REMOVE}, fetch = FetchType.EAGER)
@JoinColumn(name = "product_id")
@OrderColumn(name = "list_idx")
private List<Image> images = new ArrayList<>();

//@Embeddable 컬렉션에 대한 즉시 로딩 설정
@ElementCollection(fetch = FetchType.EAGER)
@CollectionTable(name = "order_line", joinColumns = @JoinColumn(name = "order_number"))
@OrderColumn(name = "line_idx")
private List<Option> options = new ArrayList<>();
```

- `EntityManager.find()` 호출 시, 관련된 모든 연관 객체를 **DB에서 즉시 함께 로딩**.
- 애그리거트가 완전한 상태로 로딩됨.

---

##  즉시 로딩의 단점

### 예시 상황
- `Product` 애그리거트 루트가 `Image(@Entity)` 와 `Option(@Embeddable)` 목록을 가질 경우:
    - `Product`의 `images` = 2개
    - `Product`의 `options` = 2개

### 실행 쿼리 결과
- `Hibernate`는 `Product`, `Image`, `Option` 테이블을 조인하여 하나의 쿼리를 실행
- **카타시안 곱(Cartesian Join)** 발생:
    - 결과 행 수 = 2 (images) × 2 (options) = 4
    - `Product` 정보는 4번 중복됨
    - `Image`, `Option`도 중복 포함

### 메모리 변환
- Hibernate가 중복을 제거하여:
    - `Product`: 1개
    - `Image`: 2개
    - `Option`: 2개  
      으로 변환

### 문제점
- **애그리거트가 커질수록 쿼리 성능 문제** 발생 가능
- 즉시로딩은 조회 성능 최적화를 위한 전략이지만, 오히려 **과도한 조인**으로 인해 역효과 발생 가능

---

## 애그리거트가 완전해야 하는 이유

- 애그리거트가 **상태 변경 기능을 수행할 때**
- **표현 영역(UI)** 에서 상태 정보를 **한 번에 보여줘야 할 때** (이 경우 조회 전용 기능, 모델을 구현하는 방식이 더 유리)
- 따라서 상태 변경 기능을 수행할때와 더 관련있음

---

## 지연 로딩(LAZY Fetching) 전략

### 트랜잭션 안에서 지연 로딩 활용
```java
@Transactional
public void removeOptions(ProductId id, int optIdxToBeDeleted){
    Product product = productRepository.findById(id); // Option은 아직 로딩 X
    product.removeOption(optIdxToBeDeleted);          // 여기서 로딩됨
}
```

```java
@Entity
public class Product {
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "order_line", joinColumns = @JoinColumn(name = "order_number"))
    @OrderColumn(name = "line_idx")
    private List<Option> options = new ArrayList<>();

    public void removeOption(int optIdx) {
        this.options.remove(optIdx); // 이 시점에서 로딩됨
    }
}
```

### 장점
- **조회 빈도가 높은 시스템에서 성능 효율**이 높음
- **상태 변경보다 조회가 더 자주 발생하는 일반적인 애플리케이션**에 적합
- 트랜잭션 범위 내에서는 필요한 시점에만 쿼리 실행 가능

---

## 지연 로딩 vs 즉시 로딩 요약

| 항목 | 즉시 로딩 (EAGER) | 지연 로딩 (LAZY) |
|------|--------------------|------------------|
| 로딩 시점 | 루트 로딩 시 즉시 | 실제 접근 시점에 |
| 쿼리 수 | 1개 (조인) | 다수 (N+1 위험) |
| 성능 | 데이터 적으면 빠름 | 대량 조회에 효율적 |
| 사용 시기 | 상태 변경 직전 | 읽기 중심 로직 |

---

## 주의사항

- 즉시 로딩은 `@Entity`와 `@Embeddable`에 대해 동작 방식이 다르고, JPA 구현체(Hibernate 등)에 따라 세부 구현이 다를 수 있음.
- **지연로딩은 항상 동일한 방식**으로 동작하기 때문에 예측 가능성이 높음.
- **애그리거트의 크기와 실제 사용 시나리오에 따라 로딩 전략을 결정**해야 함.
---

<br>

# 4.5 애그리거트의 영속성 전파

애그리거트가 완전한 상태여야 한다는 것은 루트를 조회 뿐만 아니라 삭제 저장할때도 하나로 처리햐야 함을 의미
- 저장 시 루트만 저장하면 안되고 모든 객체를 저장
- 삭제 시 루트 뿐만 아니라 애그리거트에 속한 모든 객체 삭제

> `@Embeddable`은 함께 저장되고 삭제 되기 때문에 cascade를 따로 설정하지 않아도 된다 반면 `@Entity`는 cascade를 사용해서 저장, 삭제시 함께 처리 되도록 한다
